<!DOCTYPE html>
<html>
<body>

<script src="fengari-web.js" type="text/javascript"></script>
<script src="js/LibDeflate.lua" type="application/lua" async></script>
<script src="js/example.lua" type="application/lua" async></script>
<script type="text/javascript">
 //fengari.load('--[[--\r\nLibDeflate 1.0.0-release <br>\r\nPure Lua compressor and decompressor with high compression ratio using\r\nDEFLATE/zlib format.\r\n\r\n@file LibDeflate.lua\r\n@author Haoqian He (Github: SafeteeWoW; World of Warcraft: Safetyy-Illidan(US))\r\n@copyright LibDeflate <2018> Haoqian He\r\n@license GNU General Public License Version 3 or later\r\n\r\nThis library is implemented according to the following specifications. <br>\r\nReport a bug if LibDeflate is not fully compliant with those specs. <br>\r\nBoth compressors and decompressors have been implemented in the library.<br>\r\n1. RFC1950: DEFLATE Compressed Data Format Specification version 1.3 <br>\r\nhttps://tools.ietf.org/html/rfc1951 <br>\r\n2. RFC1951: ZLIB Compressed Data Format Specification version 3.3 <br>\r\nhttps://tools.ietf.org/html/rfc1950 <br>\r\n\r\nThis library requires Lua 5.1/5.2/5.3 interpreter or LuaJIT v2.0+. <br>\r\nThis library does not have any dependencies. <br>\r\n<br>\r\nThis file "LibDeflate.lua" is the only source file of\r\nthe library. <br>\r\nSubmit suggestions or report bugs to\r\nhttps://github.com/safeteeWow/LibDeflate/issues\r\n]]\r\n\r\n--[[\r\nThis program is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\nany later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with this program.  If not, see https://www.gnu.org/licenses/.\r\n\r\nCredits:\r\n1. zlib, by Jean-loup Gailly (compression) and Mark Adler (decompression).\r\n\thttp://www.zlib.net/\r\n\tLicensed under zlib License. http://www.zlib.net/zlib_license.html\r\n\tFor the compression algorithm.\r\n2. puff, by Mark Adler. https://github.com/madler/zlib/tree/master/contrib/puff\r\n\tLicensed under zlib License. http://www.zlib.net/zlib_license.html\r\n\tFor the decompression algorithm.\r\n3. LibCompress, by jjsheets and Galmok of European Stormrage (Horde)\r\n\thttps://www.wowace.com/projects/libcompress\r\n\tLicensed under GPLv2.\r\n\thttps://www.gnu.org/licenses/old-licenses/gpl-2.0.html\r\n\tFor the code to create customized codec.\r\n4. WeakAuras2,\r\n\thttps://github.com/WeakAuras/WeakAuras2\r\n\tLicensed under GPLv2.\r\n\tFor the 6bit encoding and decoding.\r\n]]\r\n\r\n--[[\r\n\tCurseforge auto-packaging replacements:\r\n\r\n\tProject Date: 2018-07-29T18:58:38Z\r\n\tProject Hash: 420f583c8c1ad0d4fc12398c86e99a65cf37a79a\r\n\tProject Version: 1.0.0-release\r\n--]]\r\n\r\nlocal LibDeflate\r\n\r\ndo\r\n\t-- Semantic version. all lowercase.\r\n\t-- Suffix can be alpha1, alpha2, beta1, beta2, rc1, rc2, etc.\r\n\t-- NOTE: Two version numbers needs to modify.\r\n\t-- 1. On the top of LibDeflate.lua\r\n\t-- 2. HERE\r\n\tlocal _VERSION = "1.0.0-release"\r\n\r\n\tlocal _COPYRIGHT =\r\n\t"LibDeflate ".._VERSION\r\n\t.." Copyright (C) 2018 Haoqian He."\r\n\t.." License GPLv3+: GNU GPL version 3 or later"\r\n\r\n\t-- Register in the World of Warcraft library "LibStub" if detected.\r\n\tif LibStub then\r\n\t\tlocal MAJOR, MINOR = "LibDeflate", -1\r\n\t\t-- When MAJOR is changed, I should name it as LibDeflate2\r\n\t\tlocal lib, minor = LibStub:GetLibrary(MAJOR, true)\r\n\t\tif lib and minor and minor >= MINOR then -- No need to update.\r\n\t\t\treturn lib\r\n\t\telse -- Update or first time register\r\n\t\t\tLibDeflate = LibStub:NewLibrary(MAJOR, _VERSION)\r\n\t\t\t-- NOTE: It is important that new version has implemented\r\n\t\t\t-- all exported APIs and tables in the old version,\r\n\t\t\t-- so the old library is fully garbage collected,\r\n\t\t\t-- and we 100% ensure the backward compatibility.\r\n\t\tend\r\n\telse -- "LibStub" is not detected.\r\n\t\tLibDeflate = {}\r\n\tend\r\n\r\n\tLibDeflate._VERSION = _VERSION\r\n\tLibDeflate._COPYRIGHT = _COPYRIGHT\r\nend\r\n\r\n-- localize Lua api for faster access.\r\nlocal assert = assert\r\nlocal error = error\r\nlocal pairs = pairs\r\nlocal string_byte = string.byte\r\nlocal string_char = string.char\r\nlocal string_find = string.find\r\nlocal string_gsub = string.gsub\r\nlocal string_sub = string.sub\r\nlocal table_concat = table.concat\r\nlocal table_sort = table.sort\r\nlocal tostring = tostring\r\nlocal type = type\r\n\r\n-- Converts i to 2^i, (0<=i<=32)\r\n-- This is used to implement bit left shift and bit right shift.\r\n-- "x >> y" in C:   "(x-x%_pow2[y])/_pow2[y]" in Lua\r\n-- "x << y" in C:   "x*_pow2[y]" in Lua\r\nlocal _pow2 = {}\r\n\r\n-- Converts any byte to a character, (0<=byte<=255)\r\nlocal _byte_to_char = {}\r\n\r\n-- _reverseBitsTbl[len][val] stores the bit reverse of\r\n-- the number with bit length "len" and value "val"\r\n-- For example, decimal number 6 with bits length 5 is binary 00110\r\n-- It\'s reverse is binary 01100,\r\n-- which is decimal 12 and 12 == _reverseBitsTbl[5][6]\r\n-- 1<=len<=9, 0<=val<=2^len-1\r\n-- The reason for 1<=len<=9 is that the max of min bitlen of huffman code\r\n-- of a huffman alphabet is 9?\r\nlocal _reverse_bits_tbl = {}\r\n\r\n-- Convert a LZ77 length (3<=len<=258) to\r\n-- a deflate literal/LZ77_length code (257<=code<=285)\r\nlocal _length_to_deflate_code = {}\r\n\r\n-- convert a LZ77 length (3<=len<=258) to\r\n-- a deflate literal/LZ77_length code extra bits.\r\nlocal _length_to_deflate_extra_bits = {}\r\n\r\n-- Convert a LZ77 length (3<=len<=258) to\r\n-- a deflate literal/LZ77_length code extra bit length.\r\nlocal _length_to_deflate_extra_bitlen = {}\r\n\r\n-- Convert a small LZ77 distance (1<=dist<=256) to a deflate code.\r\nlocal _dist256_to_deflate_code = {}\r\n\r\n-- Convert a small LZ77 distance (1<=dist<=256) to\r\n-- a deflate distance code extra bits.\r\nlocal _dist256_to_deflate_extra_bits = {}\r\n\r\n-- Convert a small LZ77 distance (1<=dist<=256) to\r\n-- a deflate distance code extra bit length.\r\nlocal _dist256_to_deflate_extra_bitlen = {}\r\n\r\n-- Convert a literal/LZ77_length deflate code to LZ77 base length\r\n-- The key of the table is (code - 256), 257<=code<=285\r\nlocal _literal_deflate_code_to_base_len = {\r\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\r\n\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,\r\n}\r\n\r\n-- Convert a literal/LZ77_length deflate code to base LZ77 length extra bits\r\n-- The key of the table is (code - 256), 257<=code<=285\r\nlocal _literal_deflate_code_to_extra_bitlen = {\r\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\r\n\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\r\n}\r\n\r\n-- Convert a distance deflate code to base LZ77 distance. (0<=code<=29)\r\nlocal _dist_deflate_code_to_base_dist = {\r\n\t[0] = 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\r\n\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\r\n\t8193, 12289, 16385, 24577,\r\n}\r\n\r\n-- Convert a distance deflate code to LZ77 bits length. (0<=code<=29)\r\nlocal _dist_deflate_code_to_extra_bitlen = {\r\n\t[0] = 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\r\n\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\r\n}\r\n\r\n-- The code order of the first huffman header in the dynamic deflate block.\r\n-- See the page 12 of RFC1951\r\nlocal _rle_codes_huffman_bitlen_order = {16, 17, 18,\r\n\t0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\r\n}\r\n\r\n-- The following tables are used by fixed deflate block.\r\n-- The value of these tables are assigned at the bottom of the source.\r\n\r\n-- The huffman code of the literal/LZ77_length deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_literal_huffman_code\r\n\r\n-- Convert huffman code of the literal/LZ77_length to deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_literal_huffman_to_deflate_code\r\n\r\n-- The bit length of the huffman code of literal/LZ77_length deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_literal_huffman_bitlen\r\n\r\n-- The count of each bit length of the literal/LZ77_length deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_literal_huffman_bitlen_count\r\n\r\n-- The huffman code of the distance deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_dist_huffman_code\r\n\r\n-- Convert huffman code of the distance to deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_dist_huffman_to_deflate_code\r\n\r\n-- The bit length of the huffman code of the distance deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_dist_huffman_bitlen\r\n\r\n-- The count of each bit length of the huffman code of\r\n-- the distance deflate codes,\r\n-- in fixed deflate block.\r\nlocal _fix_block_dist_huffman_bitlen_count\r\n\r\nfor i = 0, 255 do\r\n\t_byte_to_char[i] = string_char(i)\r\nend\r\n\r\ndo\r\n\tlocal pow = 1\r\n\tfor i = 0, 32 do\r\n\t\t_pow2[i] = pow\r\n\t\tpow = pow * 2\r\n\tend\r\nend\r\n\r\nfor i = 1, 9 do\r\n\t_reverse_bits_tbl[i] = {}\r\n\tfor j=0, _pow2[i+1]-1 do\r\n\t\tlocal reverse = 0\r\n\t\tlocal value = j\r\n\t\tfor _ = 1, i do\r\n\t\t\t-- The following line is equivalent to "res | (code %2)" in C.\r\n\t\t\treverse = reverse - reverse%2\r\n\t\t\t\t+ (((reverse%2==1) or (value % 2) == 1) and 1 or 0)\r\n\t\t\tvalue = (value-value%2)/2\r\n\t\t\treverse = reverse * 2\r\n\t\tend\r\n\t\t_reverse_bits_tbl[i][j] = (reverse-reverse%2)/2\r\n\tend\r\nend\r\n\r\n-- The source code is written according to the pattern in the numbers\r\n-- in RFC1951 Page10.\r\ndo\r\n\tlocal a = 18\r\n\tlocal b = 16\r\n\tlocal c = 265\r\n\tlocal bitlen = 1\r\n\tfor len = 3, 258 do\r\n\t\tif len <= 10 then\r\n\t\t\t_length_to_deflate_code[len] = len + 254\r\n\t\t\t_length_to_deflate_extra_bitlen[len] = 0\r\n\t\telseif len == 258 then\r\n\t\t\t_length_to_deflate_code[len] = 285\r\n\t\t\t_length_to_deflate_extra_bitlen[len] = 0\r\n\t\telse\r\n\t\t\tif len > a then\r\n\t\t\t\ta = a + b\r\n\t\t\t\tb = b * 2\r\n\t\t\t\tc = c + 4\r\n\t\t\t\tbitlen = bitlen + 1\r\n\t\t\tend\r\n\t\t\tlocal t = len-a-1+b/2\r\n\t\t\t_length_to_deflate_code[len] = (t-(t%(b/8)))/(b/8) + c\r\n\t\t\t_length_to_deflate_extra_bitlen[len] = bitlen\r\n\t\t\t_length_to_deflate_extra_bits[len] = t % (b/8)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n-- The source code is written according to the pattern in the numbers\r\n-- in RFC1951 Page11.\r\ndo\r\n\t_dist256_to_deflate_code[1] = 0\r\n\t_dist256_to_deflate_code[2] = 1\r\n\t_dist256_to_deflate_extra_bitlen[1] = 0\r\n\t_dist256_to_deflate_extra_bitlen[2] = 0\r\n\r\n\tlocal a = 3\r\n\tlocal b = 4\r\n\tlocal code = 2\r\n\tlocal bitlen = 0\r\n\tfor dist = 3, 256 do\r\n\t\tif dist > b then\r\n\t\t\ta = a * 2\r\n\t\t\tb = b * 2\r\n\t\t\tcode = code + 2\r\n\t\t\tbitlen = bitlen + 1\r\n\t\tend\r\n\t\t_dist256_to_deflate_code[dist] = (dist <= a) and code or (code+1)\r\n\t\t_dist256_to_deflate_extra_bitlen[dist] = (bitlen < 0) and 0 or bitlen\r\n\t\tif b >= 8 then\r\n\t\t\t_dist256_to_deflate_extra_bits[dist] = (dist-b/2-1) % (b/4)\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--- Calculate the Adler-32 checksum of the string. <br>\r\n-- See RFC1950 Page 9 https://tools.ietf.org/html/rfc1950 for the\r\n-- definition of Adler-32 checksum.\r\n-- @param str [string] the input string to calcuate its Adler-32 checksum.\r\n-- @return [integer] The Adler-32 checksum, which is greater or equal to 0,\r\n-- and less than 2^32 (4294967296).\r\nfunction LibDeflate:Adler32(str)\r\n\t-- This function is loop unrolled by better performance.\r\n\t--\r\n\t-- Here is the minimum code:\r\n\t--\r\n\t-- local a = 1\r\n\t-- local b = 0\r\n\t-- for i=1, #str do\r\n\t-- \t\tlocal s = string.byte(str, i, i)\r\n\t-- \t\ta = (a+s)%65521\r\n\t-- \t\tb = (b+a)%65521\r\n\t-- \t\tend\r\n\t-- return b*65536+a\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:Adler32(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tlocal strlen = #str\r\n\r\n\tlocal i = 1\r\n\tlocal a = 1\r\n\tlocal b = 0\r\n\twhile i <= strlen - 15 do\r\n\t\tlocal x1, x2, x3, x4, x5, x6, x7, x8,\r\n\t\t\tx9, x10, x11, x12, x13, x14, x15, x16 = string_byte(str, i, i+15)\r\n\t\tb = (b+16*a+16*x1+15*x2+14*x3+13*x4+12*x5+11*x6+10*x7+9*x8+8*x9\r\n\t\t\t+7*x10+6*x11+5*x12+4*x13+3*x14+2*x15+x16)%65521\r\n\t\ta = (a+x1+x2+x3+x4+x5+x6+x7+x8+x9+x10+x11+x12+x13+x14+x15+x16)%65521\r\n\t\ti =  i + 16\r\n\tend\r\n\twhile (i <= strlen) do\r\n\t\tlocal x = string_byte(str, i, i)\r\n\t\ta = (a + x) % 65521\r\n\t\tb = (b + a) % 65521\r\n\t\ti = i + 1\r\n\tend\r\n\treturn (b*65536+a) % 4294967296\r\nend\r\n\r\n-- Compare adler32 checksum.\r\n-- adler32 should be compared with a mod to avoid sign problem\r\n-- 4072834167 (unsigned) is the same adler32 as -222133129\r\nlocal function IsEqualAdler32(actual, expected)\r\n\treturn (actual % 4294967296) == (expected % 4294967296)\r\nend\r\n\r\n--- Create a preset dictionary.\r\n--\r\n-- This function is not fast, and the memory consumption of the produced\r\n-- dictionary is about 50 times of the input string. Therefore, it is suggestted\r\n-- to run this function only once in your program.\r\n--\r\n-- It is very important to know that if you do use a preset dictionary,\r\n-- compressors and decompressors MUST USE THE SAME dictionary. That is,\r\n-- dictionary must be created using the same string. If you update your program\r\n-- with a new dictionary, people with the old version won\'t be able to transmit\r\n-- data with people with the new version. Therefore, changing the dictionary\r\n-- must be very careful.\r\n--\r\n-- The parameters "strlen" and "adler32" add a layer of verification to ensure\r\n-- the parameter "str" is not modified unintentionally during the program\r\n-- development.\r\n--\r\n-- @usage local dict_str = "1234567890"\r\n--\r\n-- -- print(dict_str:len(), LibDeflate:Adler32(dict_str))\r\n-- -- Hardcode the print result below to verify it to avoid acciently\r\n-- -- modification of \'str\' during the program development.\r\n-- -- string length: 10, Adler-32: 187433486,\r\n-- -- Don\'t calculate string length and its Adler-32 at run-time.\r\n--\r\n-- local dict = LibDeflate:CreateDictionary(dict_str, 10, 187433486)\r\n--\r\n-- @param str [string] The string used as the preset dictionary. <br>\r\n-- You should put stuffs that frequently appears in the dictionary\r\n-- string and preferablely put more frequently appeared stuffs toward the end\r\n-- of the string. <br>\r\n-- Empty string and string longer than 32768 bytes are not allowed.\r\n-- @param strlen [integer] The length of \'str\'. Please pass in this parameter\r\n-- as a hardcoded constant, in order to verify the content of \'str\'. The value\r\n-- of this parameter should be known before your program runs.\r\n-- @param adler32 [integer] The Adler-32 checksum of \'str\'. Please pass in this\r\n-- parameter as a hardcoded constant, in order to verify the content of \'str\'.\r\n-- The value of this parameter should be known before your program runs.\r\n-- @return  [table] The dictionary used for preset dictionary compression and\r\n-- decompression.\r\n-- @raise error if \'strlen\' does not match the length of \'str\',\r\n-- or if \'adler32\' does not match the Adler-32 checksum of \'str\'.\r\nfunction LibDeflate:CreateDictionary(str, strlen, adler32)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tif type(strlen) ~= "number" then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t.." \'strlen\' - number expected got \'%s\'."):format(\r\n\t\t\ttype(strlen)), 2)\r\n\tend\r\n\tif type(adler32) ~= "number" then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t.." \'adler32\' - number expected got \'%s\'."):format(\r\n\t\t\ttype(adler32)), 2)\r\n\tend\r\n\tif strlen ~= #str then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t\t.." \'strlen\' does not match the actual length of \'str\'."\r\n\t\t\t\t.." \'strlen\': %u, \'#str\': %u ."\r\n\t\t\t\t.." Please check if \'str\' is modified unintentionally.")\r\n\t\t\t:format(strlen, #str))\r\n\tend\r\n\tif strlen == 0 then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t.." \'str\' - Empty string is not allowed."), 2)\r\n\tend\r\n\tif strlen > 32768 then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t.." \'str\' - string longer than 32768 bytes is not allowed."\r\n\t\t\t .." Got %d bytes."):format(strlen), 2)\r\n\tend\r\n\tlocal actual_adler32 = self:Adler32(str)\r\n\tif not IsEqualAdler32(adler32, actual_adler32) then\r\n\t\terror(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"\r\n\t\t\t\t.." \'adler32\' does not match the actual adler32 of \'str\'."\r\n\t\t\t\t.." \'adler32\': %u, \'Adler32(str)\': %u ."\r\n\t\t\t\t.." Please check if \'str\' is modified unintentionally.")\r\n\t\t\t:format(adler32, actual_adler32))\r\n\tend\r\n\r\n\tlocal dictionary = {}\r\n\tdictionary.adler32 = adler32\r\n\tdictionary.hash_tables = {}\r\n\tdictionary.string_table = {}\r\n\tdictionary.strlen = strlen\r\n\tlocal string_table = dictionary.string_table\r\n\tlocal hash_tables = dictionary.hash_tables\r\n\tstring_table[1] = string_byte(str, 1, 1)\r\n\tstring_table[2] = string_byte(str, 2, 2)\r\n\tif strlen >= 3 then\r\n\t\tlocal i = 1\r\n\t\tlocal hash = string_table[1]*256+string_table[2]\r\n\t\twhile i <= strlen - 2 - 3 do\r\n\t\t\tlocal x1, x2, x3, x4 = string_byte(str, i+2, i+5)\r\n\t\t\tstring_table[i+2] = x1\r\n\t\t\tstring_table[i+3] = x2\r\n\t\t\tstring_table[i+4] = x3\r\n\t\t\tstring_table[i+5] = x4\r\n\t\t\thash = (hash*256+x1)%16777216\r\n\t\t\tlocal t = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = i-strlen\r\n\t\t\ti = i + 1\r\n\t\t\thash = (hash*256+x2)%16777216\r\n\t\t\tt = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = i-strlen\r\n\t\t\ti = i + 1\r\n\t\t\thash = (hash*256+x3)%16777216\r\n\t\t\tt = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = i-strlen\r\n\t\t\ti = i + 1\r\n\t\t\thash = (hash*256+x4)%16777216\r\n\t\t\tt = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = i-strlen\r\n\t\t\ti = i + 1\r\n\t\tend\r\n\t\twhile i <= strlen - 2 do\r\n\t\t\tlocal x = string_byte(str, i+2)\r\n\t\t\tstring_table[i+2] = x\r\n\t\t\thash = (hash*256+x)%16777216\r\n\t\t\tlocal t = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = i-strlen\r\n\t\t\ti = i + 1\r\n\t\tend\r\n\tend\r\n\treturn dictionary\r\nend\r\n\r\n-- Check if the dictionary is valid.\r\n-- @param dictionary The preset dictionary for compression and decompression.\r\n-- @return true if valid, false if not valid.\r\n-- @return if not valid, the error message.\r\nlocal function IsValidDictionary(dictionary)\r\n\tif type(dictionary) ~= "table" then\r\n\t\treturn false, ("\'dictionary\' - table expected got \'%s\'.")\r\n\t\t\t:format(type(dictionary))\r\n\tend\r\n\tif type(dictionary.adler32) ~= "number"\r\n\t\tor type(dictionary.string_table) ~= "table"\r\n\t\tor type(dictionary.strlen) ~= "number"\r\n\t\tor dictionary.strlen <= 0\r\n\t\tor dictionary.strlen > 32768\r\n\t\tor dictionary.strlen ~= #dictionary.string_table\r\n\t\tor type(dictionary.hash_tables) ~= "table"\r\n\t\tthen\r\n\t\treturn false, ("\'dictionary\' - corrupted dictionary.")\r\n\t\t\t:format(type(dictionary))\r\n\tend\r\n\treturn true, ""\r\nend\r\n\r\n--[[\r\n\tkey of the configuration table is the compression level,\r\n\tand its value stores the compression setting.\r\n\tThese numbers come from zlib source code.\r\n\r\n\tHigher compression level usually means better compression.\r\n\t(Because LibDeflate uses a simplified version of zlib algorithm,\r\n\tthere is no guarantee that higher compression level does not create\r\n\tbigger file than lower level, but I can say it\'s 99% likely)\r\n\r\n\tBe careful with the high compression level. This is a pure lua\r\n\timplementation compressor/decompressor, which is significant slower than\r\n\ta C/C++ equivalant compressor/decompressor. Very high compression level\r\n\tcosts significant more CPU time, and usually compression size won\'t be\r\n\tsignificant smaller when you increase compression level by 1, when the\r\n\tlevel is already very high. Benchmark yourself if you can afford it.\r\n\r\n\tSee also https://github.com/madler/zlib/blob/master/doc/algorithm.txt,\r\n\thttps://github.com/madler/zlib/blob/master/deflate.c for more information.\r\n\r\n\tThe meaning of each field:\r\n\t@field 1 use_lazy_evaluation:\r\n\t\ttrue/false. Whether the program uses lazy evaluation.\r\n\t\tSee what is "lazy evaluation" in the link above.\r\n\t\tlazy_evaluation improves ratio, but relatively slow.\r\n\t@field 2 good_prev_length:\r\n\t\tOnly effective if lazy is set, Only use 1/4 of max_chain,\r\n\t\tif prev length of lazy match is above this.\r\n\t@field 3 max_insert_length/max_lazy_match:\r\n\t\tIf not using lazy evaluation,\r\n\t\tinsert new strings in the hash table only if the match length is not\r\n\t\tgreater than this length.\r\n\t\tIf using lazy evaluation, only continue lazy evaluation,\r\n\t\tif previous match length is strictly smaller than this value.\r\n\t@field 4 nice_length:\r\n\t\tNumber. Don\'t continue to go down the hash chain,\r\n\t\tif match length is above this.\r\n\t@field 5 max_chain:\r\n\t\tNumber. The maximum number of hash chains we look.\r\n--]]\r\nlocal _compression_level_configs = {\r\n\t[0] = {false, nil, 0, 0, 0}, -- level 0, no compression\r\n\t[1] = {false, nil, 4, 8, 4}, -- level 1, similar to zlib level 1\r\n\t[2] = {false, nil, 5, 18, 8}, -- level 2, similar to zlib level 2\r\n\t[3] = {false, nil, 6, 32, 32},\t-- level 3, similar to zlib level 3\r\n\t[4] = {true, 4,\t4, 16, 16},\t-- level 4, similar to zlib level 4\r\n\t[5] = {true, 8,\t16,\t32,\t32}, -- level 5, similar to zlib level 5\r\n\t[6] = {true, 8,\t16,\t128, 128}, -- level 6, similar to zlib level 6\r\n\t[7] = {true, 8,\t32,\t128, 256}, -- (SLOW) level 7, similar to zlib level 7\r\n\t[8] = {true, 32, 128, 258, 1024} , --(SLOW) level 8,similar to zlib level 8\r\n\t[9] = {true, 32, 258, 258, 4096},\r\n\t\t-- (VERY SLOW) level 9, similar to zlib level 9\r\n}\r\n\r\n-- Check if the compression/decompression arguments is valid\r\n-- @param str The input string.\r\n-- @param check_dictionary if true, check if dictionary is valid.\r\n-- @param dictionary The preset dictionary for compression and decompression.\r\n-- @param check_configs if true, check if config is valid.\r\n-- @param configs The compression configuration table\r\n-- @return true if valid, false if not valid.\r\n-- @return if not valid, the error message.\r\nlocal function IsValidArguments(str,\r\n\tcheck_dictionary, dictionary,\r\n\tcheck_configs, configs)\r\n\r\n\tif type(str) ~= "string" then\r\n\t\treturn false,\r\n\t\t\t("\'str\' - string expected got \'%s\'."):format(type(str))\r\n\tend\r\n\tif check_dictionary then\r\n\t\tlocal dict_valid, dict_err = IsValidDictionary(dictionary)\r\n\t\tif not dict_valid then\r\n\t\t\treturn false, dict_err\r\n\t\tend\r\n\tend\r\n\tif check_configs then\r\n\t\tlocal type_configs = type(configs)\r\n\t\tif type_configs ~= "nil" and type_configs ~= "table" then\r\n\t\t\treturn false,\r\n\t\t\t("\'configs\' - nil or table expected got \'%s\'.")\r\n\t\t\t\t:format(type(configs))\r\n\t\tend\r\n\t\tif type_configs == "table" then\r\n\t\t\tfor k, v in pairs(configs) do\r\n\t\t\t\tif k ~= "level" and k ~= "strategy" then\r\n\t\t\t\t\treturn false,\r\n\t\t\t\t\t("\'configs\' - unsupported table key in the configs: \'%s\'.")\r\n\t\t\t\t\t:format(k)\r\n\t\t\t\telseif k == "level" and not _compression_level_configs[v] then\r\n\t\t\t\t\treturn false,\r\n\t\t\t\t\t("\'configs\' - unsupported \'level\': %s."):format(tostring(v))\r\n\t\t\t\telseif k == "strategy" and v ~= "fixed" and v ~= "huffman_only"\r\n\t\t\t\t\t\tand v ~= "dynamic" then\r\n\t\t\t\t\t\t-- random_block_type is for testing purpose\r\n\t\t\t\t\treturn false, ("\'configs\' - unsupported \'strategy\': \'%s\'.")\r\n\t\t\t\t\t\t:format(tostring(v))\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn true, ""\r\nend\r\n\r\n\r\n\r\n--[[ --------------------------------------------------------------------------\r\n\tCompress code\r\n--]] --------------------------------------------------------------------------\r\n\r\n-- partial flush to save memory\r\nlocal _FLUSH_MODE_MEMORY_CLEANUP = 0\r\n-- full flush with partial bytes\r\nlocal _FLUSH_MODE_OUTPUT = 1\r\n-- write bytes to get to byte boundary\r\nlocal _FLUSH_MODE_BYTE_BOUNDARY = 2\r\n-- no flush, just get num of bits written so far\r\nlocal _FLUSH_MODE_NO_FLUSH = 3\r\n\r\n--[[\r\n\tCreate an empty writer to easily write stuffs as the unit of bits.\r\n\tReturn values:\r\n\t1. WriteBits(code, bitlen):\r\n\t2. WriteString(str):\r\n\t3. Flush(mode):\r\n--]]\r\nlocal function CreateWriter()\r\n\tlocal buffer_size = 0\r\n\tlocal cache = 0\r\n\tlocal cache_bitlen = 0\r\n\tlocal total_bitlen = 0\r\n\tlocal buffer = {}\r\n\t-- When buffer is big enough, flush into result_buffer to save memory.\r\n\tlocal result_buffer = {}\r\n\r\n\t-- Write bits with value "value" and bit length of "bitlen" into writer.\r\n\t-- @param value: The value being written\r\n\t-- @param bitlen: The bit length of "value"\r\n\t-- @return nil\r\n\tlocal function WriteBits(value, bitlen)\r\n\t\tcache = cache + value * _pow2[cache_bitlen]\r\n\t\tcache_bitlen = cache_bitlen + bitlen\r\n\t\ttotal_bitlen = total_bitlen + bitlen\r\n\t\t-- Only bulk to buffer every 4 bytes. This is quicker.\r\n\t\tif cache_bitlen >= 32 then\r\n\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\tbuffer[buffer_size] =\r\n\t\t\t\t_byte_to_char[cache % 256]\r\n\t\t\t\t.._byte_to_char[((cache-cache%256)/256 % 256)]\r\n\t\t\t\t.._byte_to_char[((cache-cache%65536)/65536 % 256)]\r\n\t\t\t\t.._byte_to_char[((cache-cache%16777216)/16777216 % 256)]\r\n\t\t\tlocal rshift_mask = _pow2[32 - cache_bitlen + bitlen]\r\n\t\t\tcache = (value - value%rshift_mask)/rshift_mask\r\n\t\t\tcache_bitlen = cache_bitlen - 32\r\n\t\tend\r\n\tend\r\n\r\n\t-- Write the entire string into the writer.\r\n\t-- @param str The string being written\r\n\t-- @return nil\r\n\tlocal function WriteString(str)\r\n\t\tfor _ = 1, cache_bitlen, 8 do\r\n\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\tbuffer[buffer_size] = string_char(cache % 256)\r\n\t\t\tcache = (cache-cache%256)/256\r\n\t\tend\r\n\t\tcache_bitlen = 0\r\n\t\tbuffer_size = buffer_size + 1\r\n\t\tbuffer[buffer_size] = str\r\n\t\ttotal_bitlen = total_bitlen + #str*8\r\n\tend\r\n\r\n\t-- Flush current stuffs in the writer and return it.\r\n\t-- This operation will free most of the memory.\r\n\t-- @param mode See the descrtion of the constant and the source code.\r\n\t-- @return The total number of bits stored in the writer right now.\r\n\t-- for byte boundary mode, it includes the padding bits.\r\n\t-- for output mode, it does not include padding bits.\r\n\t-- @return Return the outputs if mode is output.\r\n\tlocal function FlushWriter(mode)\r\n\t\tif mode == _FLUSH_MODE_NO_FLUSH then\r\n\t\t\treturn total_bitlen\r\n\t\tend\r\n\r\n\t\tif mode == _FLUSH_MODE_OUTPUT\r\n\t\t\tor mode == _FLUSH_MODE_BYTE_BOUNDARY then\r\n\t\t\t-- Full flush, also output cache.\r\n\t\t\t-- Need to pad some bits if cache_bitlen is not multiple of 8.\r\n\t\t\tlocal padding_bitlen = (8 - cache_bitlen % 8) % 8\r\n\r\n\t\t\tif cache_bitlen > 0 then\r\n\t\t\t\t-- padding with all 1 bits, mainly because "\\000" is not\r\n\t\t\t\t-- good to be tranmitted. I do this so "\\000" is a little bit\r\n\t\t\t\t-- less frequent.\r\n\t\t\t\tcache = cache - _pow2[cache_bitlen]\r\n\t\t\t\t\t+ _pow2[cache_bitlen+padding_bitlen]\r\n\t\t\t\tfor _ = 1, cache_bitlen, 8 do\r\n\t\t\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\t\t\tbuffer[buffer_size] = _byte_to_char[cache % 256]\r\n\t\t\t\t\tcache = (cache-cache%256)/256\r\n\t\t\t\tend\r\n\r\n\t\t\t\tcache = 0\r\n\t\t\t\tcache_bitlen = 0\r\n\t\t\tend\r\n\t\t\tif mode == _FLUSH_MODE_BYTE_BOUNDARY then\r\n\t\t\t\ttotal_bitlen = total_bitlen + padding_bitlen\r\n\t\t\t\treturn total_bitlen\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlocal flushed = table_concat(buffer)\r\n\t\tbuffer = {}\r\n\t\tbuffer_size = 0\r\n\t\tresult_buffer[#result_buffer+1] = flushed\r\n\r\n\t\tif mode == _FLUSH_MODE_MEMORY_CLEANUP then\r\n\t\t\treturn total_bitlen\r\n\t\telse\r\n\t\t\treturn total_bitlen, table_concat(result_buffer)\r\n\t\tend\r\n\tend\r\n\r\n\treturn WriteBits, WriteString, FlushWriter\r\nend\r\n\r\n-- Push an element into a max heap\r\n-- @param heap A max heap whose max element is at index 1.\r\n-- @param e The element to be pushed. Assume element "e" is a table\r\n--  and comparison is done via its first entry e[1]\r\n-- @param heap_size current number of elements in the heap.\r\n--  NOTE: There may be some garbage stored in\r\n--  heap[heap_size+1], heap[heap_size+2], etc..\r\n-- @return nil\r\nlocal function MinHeapPush(heap, e, heap_size)\r\n\theap_size = heap_size + 1\r\n\theap[heap_size] = e\r\n\tlocal value = e[1]\r\n\tlocal pos = heap_size\r\n\tlocal parent_pos = (pos-pos%2)/2\r\n\r\n\twhile (parent_pos >= 1 and heap[parent_pos][1] > value) do\r\n\t\tlocal t = heap[parent_pos]\r\n\t\theap[parent_pos] = e\r\n\t\theap[pos] = t\r\n\t\tpos = parent_pos\r\n\t\tparent_pos = (parent_pos-parent_pos%2)/2\r\n\tend\r\nend\r\n\r\n-- Pop an element from a max heap\r\n-- @param heap A max heap whose max element is at index 1.\r\n-- @param heap_size current number of elements in the heap.\r\n-- @return the poped element\r\n-- Note: This function does not change table size of "heap" to save CPU time.\r\nlocal function MinHeapPop(heap, heap_size)\r\n\tlocal top = heap[1]\r\n\tlocal e = heap[heap_size]\r\n\tlocal value = e[1]\r\n\theap[1] = e\r\n\theap[heap_size] = top\r\n\theap_size = heap_size - 1\r\n\r\n\tlocal pos = 1\r\n\tlocal left_child_pos = pos * 2\r\n\tlocal right_child_pos = left_child_pos + 1\r\n\r\n\twhile (left_child_pos <= heap_size) do\r\n\t\tlocal left_child = heap[left_child_pos]\r\n\t\tif (right_child_pos <= heap_size\r\n\t\t\tand heap[right_child_pos][1] < left_child[1]) then\r\n\t\t\tlocal right_child = heap[right_child_pos]\r\n\t\t\tif right_child[1] < value then\r\n\t\t\t\theap[right_child_pos] = e\r\n\t\t\t\theap[pos] = right_child\r\n\t\t\t\tpos = right_child_pos\r\n\t\t\t\tleft_child_pos = pos * 2\r\n\t\t\t\tright_child_pos = left_child_pos + 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tif left_child[1] < value then\r\n\t\t\t\theap[left_child_pos] = e\r\n\t\t\t\theap[pos] = left_child\r\n\t\t\t\tpos = left_child_pos\r\n\t\t\t\tleft_child_pos = pos * 2\r\n\t\t\t\tright_child_pos = left_child_pos + 1\r\n\t\t\telse\r\n\t\t\t\tbreak\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\treturn top\r\nend\r\n\r\n-- Deflate defines a special huffman tree, which is unique once the bit length\r\n-- of huffman code of all symbols are known.\r\n-- @param bitlen_count Number of symbols with a specific bitlen\r\n-- @param symbol_bitlen The bit length of a symbol\r\n-- @param max_symbol The max symbol among all symbols,\r\n--\t\twhich is (number of symbols - 1)\r\n-- @param max_bitlen The max huffman bit length among all symbols.\r\n-- @return The huffman code of all symbols.\r\nlocal function GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens\r\n\t\t, max_symbol, max_bitlen)\r\n\tlocal huffman_code = 0\r\n\tlocal next_codes = {}\r\n\tlocal symbol_huffman_codes = {}\r\n\tfor bitlen = 1, max_bitlen do\r\n\t\thuffman_code = (huffman_code+(bitlen_counts[bitlen-1] or 0))*2\r\n\t\tnext_codes[bitlen] = huffman_code\r\n\tend\r\n\tfor symbol = 0, max_symbol do\r\n\t\tlocal bitlen = symbol_bitlens[symbol]\r\n\t\tif bitlen then\r\n\t\t\thuffman_code = next_codes[bitlen]\r\n\t\t\tnext_codes[bitlen] = huffman_code + 1\r\n\r\n\t\t\t-- Reverse the bits of huffman code,\r\n\t\t\t-- because most signifant bits of huffman code\r\n\t\t\t-- is stored first into the compressed data.\r\n\t\t\t-- @see RFC1951 Page5 Section 3.1.1\r\n\t\t\tif bitlen <= 9 then -- Have cached reverse for small bitlen.\r\n\t\t\t\tsymbol_huffman_codes[symbol] =\r\n\t\t\t\t\t_reverse_bits_tbl[bitlen][huffman_code]\r\n\t\t\telse\r\n\t\t\t\tlocal reverse = 0\r\n\t\t\t\tfor _ = 1, bitlen do\r\n\t\t\t\t\treverse = reverse - reverse%2\r\n\t\t\t\t\t\t+ (((reverse%2==1)\r\n\t\t\t\t\t\t\tor (huffman_code % 2) == 1) and 1 or 0)\r\n\t\t\t\t\thuffman_code = (huffman_code-huffman_code%2)/2\r\n\t\t\t\t\treverse = reverse*2\r\n\t\t\t\tend\r\n\t\t\t\tsymbol_huffman_codes[symbol] = (reverse-reverse%2)/2\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn symbol_huffman_codes\r\nend\r\n\r\n-- A helper function to sort heap elements\r\n-- a[1], b[1] is the huffman frequency\r\n-- a[2], b[2] is the symbol value.\r\nlocal function SortByFirstThenSecond(a, b)\r\n\treturn a[1] < b[1] or\r\n\t\t(a[1] == b[1] and a[2] < b[2])\r\nend\r\n\r\n-- Calculate the huffman bit length and huffman code.\r\n-- @param symbol_count: A table whose table key is the symbol, and table value\r\n--\t\tis the symbol frenquency (nil means 0 frequency).\r\n-- @param max_bitlen: See description of return value.\r\n-- @param max_symbol: The maximum symbol\r\n-- @return a table whose key is the symbol, and the value is the huffman bit\r\n--\t\tbit length. We guarantee that all bit length <= max_bitlen.\r\n--\t\tFor 0<=symbol<=max_symbol, table value could be nil if the frequency\r\n--\t\tof the symbol is 0 or nil.\r\n-- @return a table whose key is the symbol, and the value is the huffman code.\r\n-- @return a number indicating the maximum symbol whose bitlen is not 0.\r\nlocal function GetHuffmanBitlenAndCode(symbol_counts, max_bitlen, max_symbol)\r\n\tlocal heap_size\r\n\tlocal max_non_zero_bitlen_symbol = -1\r\n\tlocal leafs = {}\r\n\tlocal heap = {}\r\n\tlocal symbol_bitlens = {}\r\n\tlocal symbol_codes = {}\r\n\tlocal bitlen_counts = {}\r\n\r\n\t--[[\r\n\t\ttree[1]: weight, temporarily used as parent and bitLengths\r\n\t\ttree[2]: symbol\r\n\t\ttree[3]: left child\r\n\t\ttree[4]: right child\r\n\t--]]\r\n\tlocal number_unique_symbols = 0\r\n\tfor symbol, count in pairs(symbol_counts) do\r\n\t\tnumber_unique_symbols = number_unique_symbols + 1\r\n\t\tleafs[number_unique_symbols] = {count, symbol}\r\n\tend\r\n\r\n\tif (number_unique_symbols == 0) then\r\n\t\t-- no code.\r\n\t\treturn {}, {}, -1\r\n\telseif (number_unique_symbols == 1) then\r\n\t\t-- Only one code. In this case, its huffman code\r\n\t\t-- needs to be assigned as 0, and bit length is 1.\r\n\t\t-- This is the only case that the return result\r\n\t\t-- represents an imcomplete huffman tree.\r\n\t\tlocal symbol = leafs[1][2]\r\n\t\tsymbol_bitlens[symbol] = 1\r\n\t\tsymbol_codes[symbol] = 0\r\n\t\treturn symbol_bitlens, symbol_codes, symbol\r\n\telse\r\n\t\ttable_sort(leafs, SortByFirstThenSecond)\r\n\t\theap_size = number_unique_symbols\r\n\t\tfor i = 1, heap_size do\r\n\t\t\theap[i] = leafs[i]\r\n\t\tend\r\n\r\n\t\twhile (heap_size > 1) do\r\n\t\t\t-- Note: pop does not change table size of heap\r\n\t\t\tlocal leftChild = MinHeapPop(heap, heap_size)\r\n\t\t\theap_size = heap_size - 1\r\n\t\t\tlocal rightChild = MinHeapPop(heap, heap_size)\r\n\t\t\theap_size = heap_size - 1\r\n\t\t\tlocal newNode =\r\n\t\t\t\t{leftChild[1]+rightChild[1], -1, leftChild, rightChild}\r\n\t\t\tMinHeapPush(heap, newNode, heap_size)\r\n\t\t\theap_size = heap_size + 1\r\n\t\tend\r\n\r\n\t\t-- Number of leafs whose bit length is greater than max_len.\r\n\t\tlocal number_bitlen_overflow = 0\r\n\r\n\t\t-- Calculate bit length of all nodes\r\n\t\tlocal fifo = {heap[1], 0, 0, 0} -- preallocate some spaces.\r\n\t\tlocal fifo_size = 1\r\n\t\tlocal index = 1\r\n\t\theap[1][1] = 0\r\n\t\twhile (index <= fifo_size) do -- Breath first search\r\n\t\t\tlocal e = fifo[index]\r\n\t\t\tlocal bitlen = e[1]\r\n\t\t\tlocal symbol = e[2]\r\n\t\t\tlocal left_child = e[3]\r\n\t\t\tlocal right_child = e[4]\r\n\t\t\tif left_child then\r\n\t\t\t\tfifo_size = fifo_size + 1\r\n\t\t\t\tfifo[fifo_size] = left_child\r\n\t\t\t\tleft_child[1] = bitlen + 1\r\n\t\t\tend\r\n\t\t\tif right_child then\r\n\t\t\t\tfifo_size = fifo_size + 1\r\n\t\t\t\tfifo[fifo_size] = right_child\r\n\t\t\t\tright_child[1] = bitlen + 1\r\n\t\t\tend\r\n\t\t\tindex = index + 1\r\n\r\n\t\t\tif (bitlen > max_bitlen) then\r\n\t\t\t\tnumber_bitlen_overflow = number_bitlen_overflow + 1\r\n\t\t\t\tbitlen = max_bitlen\r\n\t\t\tend\r\n\t\t\tif symbol >= 0 then\r\n\t\t\t\tsymbol_bitlens[symbol] = bitlen\r\n\t\t\t\tmax_non_zero_bitlen_symbol =\r\n\t\t\t\t\t(symbol > max_non_zero_bitlen_symbol)\r\n\t\t\t\t\tand symbol or max_non_zero_bitlen_symbol\r\n\t\t\t\tbitlen_counts[bitlen] = (bitlen_counts[bitlen] or 0) + 1\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\t-- Resolve bit length overflow\r\n\t\t-- @see ZLib/trees.c:gen_bitlen(s, desc), for reference\r\n\t\tif (number_bitlen_overflow > 0) then\r\n\t\t\trepeat\r\n\t\t\t\tlocal bitlen = max_bitlen - 1\r\n\t\t\t\twhile ((bitlen_counts[bitlen] or 0) == 0) do\r\n\t\t\t\t\tbitlen = bitlen - 1\r\n\t\t\t\tend\r\n\t\t\t\t-- move one leaf down the tree\r\n\t\t\t\tbitlen_counts[bitlen] = bitlen_counts[bitlen] - 1\r\n\t\t\t\t-- move one overflow item as its brother\r\n\t\t\t\tbitlen_counts[bitlen+1] = (bitlen_counts[bitlen+1] or 0) + 2\r\n\t\t\t\tbitlen_counts[max_bitlen] = bitlen_counts[max_bitlen] - 1\r\n\t\t\t\tnumber_bitlen_overflow = number_bitlen_overflow - 2\r\n\t\t\tuntil (number_bitlen_overflow <= 0)\r\n\r\n\t\t\tindex = 1\r\n\t\t\tfor bitlen = max_bitlen, 1, -1 do\r\n\t\t\t\tlocal n = bitlen_counts[bitlen] or 0\r\n\t\t\t\twhile (n > 0) do\r\n\t\t\t\t\tlocal symbol = leafs[index][2]\r\n\t\t\t\t\tsymbol_bitlens[symbol] = bitlen\r\n\t\t\t\t\tn = n - 1\r\n\t\t\t\t\tindex = index + 1\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tsymbol_codes = GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,\r\n\t\t\t\tmax_symbol, max_bitlen)\r\n\t\treturn symbol_bitlens, symbol_codes, max_non_zero_bitlen_symbol\r\n\tend\r\nend\r\n\r\n-- Calculate the first huffman header in the dynamic huffman block\r\n-- @see RFC1951 Page 12\r\n-- @param lcode_bitlen: The huffman bit length of literal/LZ77_length.\r\n-- @param max_non_zero_bitlen_lcode: The maximum literal/LZ77_length symbol\r\n--\t\twhose huffman bit length is not zero.\r\n-- @param dcode_bitlen: The huffman bit length of LZ77 distance.\r\n-- @param max_non_zero_bitlen_dcode: The maximum LZ77 distance symbol\r\n--\t\twhose huffman bit length is not zero.\r\n-- @return The run length encoded codes.\r\n-- @return The extra bits. One entry for each rle code that needs extra bits.\r\n--\t\t(code == 16 or 17 or 18).\r\n-- @return The count of appearance of each rle codes.\r\nlocal function RunLengthEncodeHuffmanBitlen(\r\n\t\tlcode_bitlens,\r\n\t\tmax_non_zero_bitlen_lcode,\r\n\t\tdcode_bitlens,\r\n\t\tmax_non_zero_bitlen_dcode)\r\n\tlocal rle_code_tblsize = 0\r\n\tlocal rle_codes = {}\r\n\tlocal rle_code_counts = {}\r\n\tlocal rle_extra_bits_tblsize = 0\r\n\tlocal rle_extra_bits = {}\r\n\tlocal prev = nil\r\n\tlocal count = 0\r\n\r\n\t-- If there is no distance code, assume one distance code of bit length 0.\r\n\t-- RFC1951: One distance code of zero bits means that\r\n\t-- there are no distance codes used at all (the data is all literals).\r\n\tmax_non_zero_bitlen_dcode = (max_non_zero_bitlen_dcode < 0)\r\n\t\t\tand 0 or max_non_zero_bitlen_dcode\r\n\tlocal max_code = max_non_zero_bitlen_lcode+max_non_zero_bitlen_dcode+1\r\n\r\n\tfor code = 0, max_code+1 do\r\n\t\tlocal len = (code <= max_non_zero_bitlen_lcode)\r\n\t\t\tand (lcode_bitlens[code] or 0)\r\n\t\t\tor ((code <= max_code)\r\n\t\t\tand (dcode_bitlens[code-max_non_zero_bitlen_lcode-1] or 0) or nil)\r\n\t\tif len == prev then\r\n\t\t\tcount = count + 1\r\n\t\t\tif len ~= 0 and count == 6 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = 16\r\n\t\t\t\trle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\r\n\t\t\t\trle_extra_bits[rle_extra_bits_tblsize] = 3\r\n\t\t\t\trle_code_counts[16] = (rle_code_counts[16] or 0) + 1\r\n\t\t\t\tcount = 0\r\n\t\t\telseif len == 0 and count == 138 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = 18\r\n\t\t\t\trle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\r\n\t\t\t\trle_extra_bits[rle_extra_bits_tblsize] = 127\r\n\t\t\t\trle_code_counts[18] = (rle_code_counts[18] or 0) + 1\r\n\t\t\t\tcount = 0\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tif count == 1 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = prev\r\n\t\t\t\trle_code_counts[prev] = (rle_code_counts[prev] or 0) + 1\r\n\t\t\telseif count == 2 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = prev\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = prev\r\n\t\t\t\trle_code_counts[prev] = (rle_code_counts[prev] or 0) + 2\r\n\t\t\telseif count >= 3 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\tlocal rleCode = (prev ~= 0) and 16 or (count <= 10 and 17 or 18)\r\n\t\t\t\trle_codes[rle_code_tblsize] = rleCode\r\n\t\t\t\trle_code_counts[rleCode] = (rle_code_counts[rleCode] or 0) + 1\r\n\t\t\t\trle_extra_bits_tblsize = rle_extra_bits_tblsize + 1\r\n\t\t\t\trle_extra_bits[rle_extra_bits_tblsize] =\r\n\t\t\t\t\t(count <= 10) and (count - 3) or (count - 11)\r\n\t\t\tend\r\n\r\n\t\t\tprev = len\r\n\t\t\tif len and len ~= 0 then\r\n\t\t\t\trle_code_tblsize = rle_code_tblsize + 1\r\n\t\t\t\trle_codes[rle_code_tblsize] = len\r\n\t\t\t\trle_code_counts[len] = (rle_code_counts[len] or 0) + 1\r\n\t\t\t\tcount = 0\r\n\t\t\telse\r\n\t\t\t\tcount = 1\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\treturn rle_codes, rle_extra_bits, rle_code_counts\r\nend\r\n\r\n-- Load the string into a table, in order to speed up LZ77.\r\n-- Loop unrolled 16 times to speed this function up.\r\n-- @param str The string to be loaded.\r\n-- @param t The load destination\r\n-- @param start str[index] will be the first character to be loaded.\r\n-- @param end str[index] will be the last character to be loaded\r\n-- @param offset str[index] will be loaded into t[index-offset]\r\n-- @return t\r\nlocal function LoadStringToTable(str, t, start, stop, offset)\r\n\tlocal i = start - offset\r\n\twhile i <= stop - 15 - offset do\r\n\t\tt[i], t[i+1], t[i+2], t[i+3], t[i+4], t[i+5], t[i+6], t[i+7], t[i+8],\r\n\t\tt[i+9], t[i+10], t[i+11], t[i+12], t[i+13], t[i+14], t[i+15] =\r\n\t\t\tstring_byte(str, i + offset, i + 15 + offset)\r\n\t\ti = i + 16\r\n\tend\r\n\twhile (i <= stop - offset) do\r\n\t\tt[i] = string_byte(str, i + offset, i + offset)\r\n\t\ti = i + 1\r\n\tend\r\n\treturn t\r\nend\r\n\r\n-- Do LZ77 process. This function uses the majority of the CPU time.\r\n-- @see zlib/deflate.c:deflate_fast(), zlib/deflate.c:deflate_slow()\r\n-- @see https://github.com/madler/zlib/blob/master/doc/algorithm.txt\r\n-- This function uses the algorithms used above. You should read the\r\n-- algorithm.txt above to understand what is the hash function and the\r\n-- lazy evaluation.\r\n--\r\n-- The special optimization used here is hash functions used here.\r\n-- The hash function is just the multiplication of the three consective\r\n-- characters. So if the hash matches, it guarantees 3 characters are matched.\r\n-- This optimization can be implemented because Lua table is a hash table.\r\n--\r\n-- @param level integer that describes compression level.\r\n-- @param string_table table that stores the value of string to be compressed.\r\n--\t\t\tThe index of this table starts from 1.\r\n--\t\t\tThe caller needs to make sure all values needed by this function\r\n--\t\t\tare loaded.\r\n--\t\t\tAssume "str" is the origin input string into the compressor\r\n--\t\t\tstr[block_start]..str[block_end+3] needs to be loaded into\r\n--\t\t\tstring_table[block_start-offset]..string_table[block_end-offset]\r\n--\t\t\tIf dictionary is presented, the last 258 bytes of the dictionary\r\n--\t\t\tneeds to be loaded into sing_table[-257..0]\r\n--\t\t\t(See more in the description of offset.)\r\n-- @param hash_tables. The table key is the hash value (0<=hash<=16777216=256^3)\r\n--\t\t\tThe table value is an array0 that stores the indexes of the\r\n--\t\t\tinput data string to be compressed, such that\r\n--\t\t\thash == str[index]*str[index+1]*str[index+2]\r\n--\t\t\tIndexes are ordered in this array.\r\n-- @param block_start The indexes of the input data string to be compressed.\r\n--\t\t\t\tthat starts the LZ77 block.\r\n-- @param block_end The indexes of the input data string to be compressed.\r\n--\t\t\t\tthat stores the LZ77 block.\r\n-- @param offset str[index] is stored in string_table[index-offset],\r\n--\t\t\tThis offset is mainly an optimization to limit the index\r\n--\t\t\tof string_table, so lua can access this table quicker.\r\n-- @param dictionary See LibDeflate:CreateDictionary\r\n-- @return literal/LZ77_length deflate codes.\r\n-- @return the extra bits of literal/LZ77_length deflate codes.\r\n-- @return the count of each literal/LZ77 deflate code.\r\n-- @return LZ77 distance deflate codes.\r\n-- @return the extra bits of LZ77 distance deflate codes.\r\n-- @return the count of each LZ77 distance deflate code.\r\nlocal function GetBlockLZ77Result(level, string_table, hash_tables, block_start,\r\n\t\tblock_end, offset, dictionary)\r\n\tlocal config = _compression_level_configs[level]\r\n\tlocal config_use_lazy\r\n\t\t, config_good_prev_length\r\n\t\t, config_max_lazy_match\r\n\t\t, config_nice_length\r\n\t\t, config_max_hash_chain =\r\n\t\t\tconfig[1], config[2], config[3], config[4], config[5]\r\n\r\n\tlocal config_max_insert_length = (not config_use_lazy)\r\n\t\tand config_max_lazy_match or 2147483646\r\n\tlocal config_good_hash_chain =\r\n\t\t(config_max_hash_chain-config_max_hash_chain%4/4)\r\n\r\n\tlocal hash\r\n\r\n\tlocal dict_hash_tables\r\n\tlocal dict_string_table\r\n\tlocal dict_string_len = 0\r\n\r\n\tif dictionary then\r\n\t\tdict_hash_tables = dictionary.hash_tables\r\n\t\tdict_string_table = dictionary.string_table\r\n\t\tdict_string_len = dictionary.strlen\r\n\t\tassert(block_start == 1)\r\n\t\tif block_end >= block_start and dict_string_len >= 2 then\r\n\t\t\thash = dict_string_table[dict_string_len-1]*65536\r\n\t\t\t\t+ dict_string_table[dict_string_len]*256 + string_table[1]\r\n\t\t\tlocal t = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = -1\r\n\t\tend\r\n\t\tif block_end >= block_start+1 and dict_string_len >= 1 then\r\n\t\t\thash = dict_string_table[dict_string_len]*65536\r\n\t\t\t\t+ string_table[1]*256 + string_table[2]\r\n\t\t\tlocal t = hash_tables[hash]\r\n\t\t\tif not t then t = {}; hash_tables[hash] = t end\r\n\t\t\tt[#t+1] = 0\r\n\t\tend\r\n\tend\r\n\r\n\thash = (string_table[block_start-offset] or 0)*256\r\n\t\t+ (string_table[block_start+1-offset] or 0)\r\n\r\n\tlocal lcodes = {}\r\n\tlocal lcode_tblsize = 0\r\n\tlocal lcodes_counts = {}\r\n\tlocal dcodes = {}\r\n\tlocal dcodes_tblsize = 0\r\n\tlocal dcodes_counts = {}\r\n\r\n\tlocal lextra_bits = {}\r\n\tlocal lextra_bits_tblsize = 0\r\n\tlocal dextra_bits = {}\r\n\tlocal dextra_bits_tblsize = 0\r\n\r\n\tlocal match_available = false\r\n\tlocal prev_len\r\n\tlocal prev_dist\r\n\tlocal cur_len = 0\r\n\tlocal cur_dist = 0\r\n\r\n\tlocal index = block_start\r\n\tlocal index_end = block_end + (config_use_lazy and 1 or 0)\r\n\r\n\t-- the zlib source code writes separate code for lazy evaluation and\r\n\t-- not lazy evaluation, which is easier to understand.\r\n\t-- I put them together, so it is a bit harder to understand.\r\n\t-- because I think this is easier for me to maintain it.\r\n\twhile (index <= index_end) do\r\n\t\tlocal string_table_index = index - offset\r\n\t\tprev_len = cur_len\r\n\t\tprev_dist = cur_dist\r\n\t\tcur_len = 0\r\n\r\n\t\thash = (hash*256+(string_table[string_table_index+2] or 0))%16777216\r\n\r\n\t\tlocal chain_index\r\n\t\tlocal cur_chain\r\n\t\tlocal hash_chain = hash_tables[hash]\r\n\t\tlocal chain_old_size\r\n\t\tif not hash_chain then\r\n\t\t\tchain_old_size = 0\r\n\t\t\thash_chain = {}\r\n\t\t\thash_tables[hash] = hash_chain\r\n\t\t\tif dict_hash_tables then\r\n\t\t\t\tcur_chain = dict_hash_tables[hash]\r\n\t\t\t\tchain_index = cur_chain and #cur_chain or 0\r\n\t\t\telse\r\n\t\t\t\tchain_index = 0\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tchain_old_size = #hash_chain\r\n\t\t\tcur_chain = hash_chain\r\n\t\t\tchain_index = chain_old_size\r\n\t\tend\r\n\r\n\t\tif index <= block_end then\r\n\t\t\thash_chain[chain_old_size+1] = index\r\n\t\tend\r\n\r\n\t\tif (chain_index > 0 and index + 2 <= block_end\r\n\t\t\tand (not config_use_lazy or prev_len < config_max_lazy_match)) then\r\n\r\n\t\t\tlocal depth =\r\n\t\t\t\t(config_use_lazy and prev_len >= config_good_prev_length)\r\n\t\t\t\tand config_good_hash_chain or config_max_hash_chain\r\n\r\n\t\t\twhile chain_index >= 1 and depth > 0 do\r\n\t\t\t\tlocal prev = cur_chain[chain_index]\r\n\r\n\t\t\t\tif index - prev > 32768 then\r\n\t\t\t\t\tbreak\r\n\t\t\t\tend\r\n\t\t\t\tif prev < index then\r\n\t\t\t\t\tlocal j = 3\r\n\r\n\t\t\t\t\tif prev >= -257 then\r\n\t\t\t\t\t\tlocal prev_table_index = prev-offset\r\n\t\t\t\t\t\t-- NOTE for author:\r\n\t\t\t\t\t\t-- j < 258 and index + j <= block_end\r\n\t\t\t\t\t\t-- This is the right condition\r\n\t\t\t\t\t\twhile (j < 258 and index + j <= block_end) do\r\n\t\t\t\t\t\t\tif (string_table[prev_table_index+j]\r\n\t\t\t\t\t\t\t\t== string_table[string_table_index+j]) then\r\n\t\t\t\t\t\t\t\tj = j + 1\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlocal prev_table_index = dict_string_len+prev\r\n\t\t\t\t\t\t-- NOTE for author:\r\n\t\t\t\t\t\t-- j < 258 and index + j <= block_end\r\n\t\t\t\t\t\t-- This is the right condition\r\n\t\t\t\t\t\twhile (j < 258 and index + j <= block_end) do\r\n\t\t\t\t\t\t\tif (dict_string_table[prev_table_index+j]\r\n\t\t\t\t\t\t\t\t== string_table[string_table_index+j]) then\r\n\t\t\t\t\t\t\t\tj = j + 1\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif j > cur_len then\r\n\t\t\t\t\t\tcur_len = j\r\n\t\t\t\t\t\tcur_dist = index - prev\r\n\t\t\t\t\tend\r\n\t\t\t\t\tif cur_len >= config_nice_length then\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\r\n\t\t\t\tchain_index = chain_index - 1\r\n\t\t\t\tdepth = depth - 1\r\n\t\t\t\tif chain_index == 0 and prev > 0 and dict_hash_tables then\r\n\t\t\t\t\tcur_chain = dict_hash_tables[hash]\r\n\t\t\t\t\tchain_index = cur_chain and #cur_chain or 0\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif not config_use_lazy then\r\n\t\t\tprev_len, prev_dist = cur_len, cur_dist\r\n\t\tend\r\n\t\tif ((not config_use_lazy or match_available)\r\n\t\t\tand (prev_len > 3 or (prev_len == 3 and prev_dist < 4096))\r\n\t\t\tand cur_len <= prev_len )then\r\n\t\t\tlocal code = _length_to_deflate_code[prev_len]\r\n\t\t\tlocal length_extra_bits_bitlen =\r\n\t\t\t\t_length_to_deflate_extra_bitlen[prev_len]\r\n\t\t\tlocal dist_code, dist_extra_bits_bitlen, dist_extra_bits\r\n\t\t\tif prev_dist <= 256 then -- have cached code for small distance.\r\n\t\t\t\tdist_code = _dist256_to_deflate_code[prev_dist]\r\n\t\t\t\tdist_extra_bits = _dist256_to_deflate_extra_bits[prev_dist]\r\n\t\t\t\tdist_extra_bits_bitlen =\r\n\t\t\t\t\t_dist256_to_deflate_extra_bitlen[prev_dist]\r\n\t\t\telse\r\n\t\t\t\tdist_code = 16\r\n\t\t\t\tdist_extra_bits_bitlen = 7\r\n\t\t\t\tlocal a = 384\r\n\t\t\t\tlocal b = 512\r\n\r\n\t\t\t\twhile true do\r\n\t\t\t\t\tif prev_dist <= a then\r\n\t\t\t\t\t\tdist_extra_bits = (prev_dist-(b/2)-1) % (b/4)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\telseif prev_dist <= b then\r\n\t\t\t\t\t\tdist_extra_bits = (prev_dist-(b/2)-1) % (b/4)\r\n\t\t\t\t\t\tdist_code = dist_code + 1\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdist_code = dist_code + 2\r\n\t\t\t\t\t\tdist_extra_bits_bitlen = dist_extra_bits_bitlen + 1\r\n\t\t\t\t\t\ta = a*2\r\n\t\t\t\t\t\tb = b*2\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tlcode_tblsize = lcode_tblsize + 1\r\n\t\t\tlcodes[lcode_tblsize] = code\r\n\t\t\tlcodes_counts[code] = (lcodes_counts[code] or 0) + 1\r\n\r\n\t\t\tdcodes_tblsize = dcodes_tblsize + 1\r\n\t\t\tdcodes[dcodes_tblsize] = dist_code\r\n\t\t\tdcodes_counts[dist_code] = (dcodes_counts[dist_code] or 0) + 1\r\n\r\n\t\t\tif length_extra_bits_bitlen > 0 then\r\n\t\t\t\tlocal lenExtraBits = _length_to_deflate_extra_bits[prev_len]\r\n\t\t\t\tlextra_bits_tblsize = lextra_bits_tblsize + 1\r\n\t\t\t\tlextra_bits[lextra_bits_tblsize] = lenExtraBits\r\n\t\t\tend\r\n\t\t\tif dist_extra_bits_bitlen > 0 then\r\n\t\t\t\tdextra_bits_tblsize = dextra_bits_tblsize + 1\r\n\t\t\t\tdextra_bits[dextra_bits_tblsize] = dist_extra_bits\r\n\t\t\tend\r\n\r\n\t\t\tfor i=index+1, index+prev_len-(config_use_lazy and 2 or 1) do\r\n\t\t\t\thash = (hash*256+(string_table[i-offset+2] or 0))%16777216\r\n\t\t\t\tif prev_len <= config_max_insert_length then\r\n\t\t\t\t\thash_chain = hash_tables[hash]\r\n\t\t\t\t\tif not hash_chain then\r\n\t\t\t\t\t\thash_chain = {}\r\n\t\t\t\t\t\thash_tables[hash] = hash_chain\r\n\t\t\t\t\tend\r\n\t\t\t\t\thash_chain[#hash_chain+1] = i\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tindex = index + prev_len - (config_use_lazy and 1 or 0)\r\n\t\t\tmatch_available = false\r\n\t\telseif (not config_use_lazy) or match_available then\r\n\t\t\tlocal code = string_table[config_use_lazy\r\n\t\t\t\tand (string_table_index-1) or string_table_index]\r\n\t\t\tlcode_tblsize = lcode_tblsize + 1\r\n\t\t\tlcodes[lcode_tblsize] = code\r\n\t\t\tlcodes_counts[code] = (lcodes_counts[code] or 0) + 1\r\n\t\t\tindex = index + 1\r\n\t\telse\r\n\t\t\tmatch_available = true\r\n\t\t\tindex = index + 1\r\n\t\tend\r\n\tend\r\n\r\n\t-- Write "end of block" symbol\r\n\tlcode_tblsize = lcode_tblsize + 1\r\n\tlcodes[lcode_tblsize] = 256\r\n\tlcodes_counts[256] = (lcodes_counts[256] or 0) + 1\r\n\r\n\treturn lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits\r\n\t\t, dcodes_counts\r\nend\r\n\r\n-- Get the header data of dynamic block.\r\n-- @param lcodes_count The count of each literal/LZ77_length codes.\r\n-- @param dcodes_count The count of each Lz77 distance codes.\r\n-- @return a lots of stuffs.\r\n-- @see RFC1951 Page 12\r\nlocal function GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)\r\n\tlocal lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t, max_non_zero_bitlen_lcode =\r\n\t\tGetHuffmanBitlenAndCode(lcodes_counts, 15, 285)\r\n\tlocal dcodes_huffman_bitlens, dcodes_huffman_codes\r\n\t\t, max_non_zero_bitlen_dcode =\r\n\t\tGetHuffmanBitlenAndCode(dcodes_counts, 15, 29)\r\n\r\n\tlocal rle_deflate_codes, rle_extra_bits, rle_codes_counts =\r\n\t\tRunLengthEncodeHuffmanBitlen(lcodes_huffman_bitlens\r\n\t\t,max_non_zero_bitlen_lcode, dcodes_huffman_bitlens\r\n\t\t, max_non_zero_bitlen_dcode)\r\n\r\n\tlocal rle_codes_huffman_bitlens, rle_codes_huffman_codes =\r\n\t\tGetHuffmanBitlenAndCode(rle_codes_counts, 7, 18)\r\n\r\n\tlocal HCLEN = 0\r\n\tfor i = 1, 19 do\r\n\t\tlocal symbol = _rle_codes_huffman_bitlen_order[i]\r\n\t\tlocal length = rle_codes_huffman_bitlens[symbol] or 0\r\n\t\tif length ~= 0 then\r\n\t\t\tHCLEN = i\r\n\t\tend\r\n\tend\r\n\r\n\tHCLEN = HCLEN - 4\r\n\tlocal HLIT = max_non_zero_bitlen_lcode + 1 - 257\r\n\tlocal HDIST = max_non_zero_bitlen_dcode + 1 - 1\r\n\tif HDIST < 0 then HDIST = 0 end\r\n\r\n\treturn HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens\r\n\t\t, rle_codes_huffman_codes, rle_deflate_codes, rle_extra_bits\r\n\t\t, lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t, dcodes_huffman_bitlens, dcodes_huffman_codes\r\nend\r\n\r\n-- Get the size of dynamic block without writing any bits into the writer.\r\n-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()\r\n-- @return the bit length of the dynamic block\r\nlocal function GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN\r\n\t, rle_codes_huffman_bitlens, rle_deflate_codes\r\n\t, lcodes_huffman_bitlens, dcodes_huffman_bitlens)\r\n\r\n\tlocal block_bitlen = 17 -- 1+2+5+5+4\r\n\tblock_bitlen = block_bitlen + (HCLEN+4)*3\r\n\r\n\tfor i = 1, #rle_deflate_codes do\r\n\t\tlocal code = rle_deflate_codes[i]\r\n\t\tblock_bitlen = block_bitlen + rle_codes_huffman_bitlens[code]\r\n\t\tif code >= 16 then\r\n\t\t\tblock_bitlen = block_bitlen +\r\n\t\t\t((code == 16) and 2 or (code == 17 and 3 or 7))\r\n\t\tend\r\n\tend\r\n\r\n\tlocal length_code_count = 0\r\n\tfor i = 1, #lcodes do\r\n\t\tlocal code = lcodes[i]\r\n\t\tlocal huffman_bitlen = lcodes_huffman_bitlens[code]\r\n\t\tblock_bitlen = block_bitlen + huffman_bitlen\r\n\t\tif code > 256 then -- Length code\r\n\t\t\tlength_code_count = length_code_count + 1\r\n\t\t\tif code > 264 and code < 285 then -- Length code with extra bits\r\n\t\t\t\tlocal extra_bits_bitlen =\r\n\t\t\t\t\t_literal_deflate_code_to_extra_bitlen[code-256]\r\n\t\t\t\tblock_bitlen = block_bitlen + extra_bits_bitlen\r\n\t\t\tend\r\n\t\t\tlocal dist_code = dcodes[length_code_count]\r\n\t\t\tlocal dist_huffman_bitlen = dcodes_huffman_bitlens[dist_code]\r\n\t\t\tblock_bitlen = block_bitlen + dist_huffman_bitlen\r\n\r\n\t\t\tif dist_code > 3 then -- dist code with extra bits\r\n\t\t\t\tlocal dist_extra_bits_bitlen = (dist_code-dist_code%2)/2 - 1\r\n\t\t\t\tblock_bitlen = block_bitlen + dist_extra_bits_bitlen\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn block_bitlen\r\nend\r\n\r\n-- Write dynamic block.\r\n-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()\r\nlocal function CompressDynamicHuffmanBlock(WriteBits, is_last_block\r\n\t\t, lcodes, lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN\r\n\t\t, rle_codes_huffman_bitlens, rle_codes_huffman_codes\r\n\t\t, rle_deflate_codes, rle_extra_bits\r\n\t\t, lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t, dcodes_huffman_bitlens, dcodes_huffman_codes)\r\n\r\n\tWriteBits(is_last_block and 1 or 0, 1) -- Last block identifier\r\n\tWriteBits(2, 2) -- Dynamic Huffman block identifier\r\n\r\n\tWriteBits(HLIT, 5)\r\n\tWriteBits(HDIST, 5)\r\n\tWriteBits(HCLEN, 4)\r\n\r\n\tfor i = 1, HCLEN+4 do\r\n\t\tlocal symbol = _rle_codes_huffman_bitlen_order[i]\r\n\t\tlocal length = rle_codes_huffman_bitlens[symbol] or 0\r\n\t\tWriteBits(length, 3)\r\n\tend\r\n\r\n\tlocal rleExtraBitsIndex = 1\r\n\tfor i=1, #rle_deflate_codes do\r\n\t\tlocal code = rle_deflate_codes[i]\r\n\t\tWriteBits(rle_codes_huffman_codes[code]\r\n\t\t\t, rle_codes_huffman_bitlens[code])\r\n\t\tif code >= 16 then\r\n\t\t\tlocal extraBits = rle_extra_bits[rleExtraBitsIndex]\r\n\t\t\tWriteBits(extraBits, (code == 16) and 2 or (code == 17 and 3 or 7))\r\n\t\t\trleExtraBitsIndex = rleExtraBitsIndex + 1\r\n\t\tend\r\n\tend\r\n\r\n\tlocal length_code_count = 0\r\n\tlocal length_code_with_extra_count = 0\r\n\tlocal dist_code_with_extra_count = 0\r\n\r\n\tfor i=1, #lcodes do\r\n\t\tlocal deflate_codee = lcodes[i]\r\n\t\tlocal huffman_code = lcodes_huffman_codes[deflate_codee]\r\n\t\tlocal huffman_bitlen = lcodes_huffman_bitlens[deflate_codee]\r\n\t\tWriteBits(huffman_code, huffman_bitlen)\r\n\t\tif deflate_codee > 256 then -- Length code\r\n\t\t\tlength_code_count = length_code_count + 1\r\n\t\t\tif deflate_codee > 264 and deflate_codee < 285 then\r\n\t\t\t\t-- Length code with extra bits\r\n\t\t\t\tlength_code_with_extra_count = length_code_with_extra_count + 1\r\n\t\t\t\tlocal extra_bits = lextra_bits[length_code_with_extra_count]\r\n\t\t\t\tlocal extra_bits_bitlen =\r\n\t\t\t\t\t_literal_deflate_code_to_extra_bitlen[deflate_codee-256]\r\n\t\t\t\tWriteBits(extra_bits, extra_bits_bitlen)\r\n\t\t\tend\r\n\t\t\t-- Write distance code\r\n\t\t\tlocal dist_deflate_code = dcodes[length_code_count]\r\n\t\t\tlocal dist_huffman_code = dcodes_huffman_codes[dist_deflate_code]\r\n\t\t\tlocal dist_huffman_bitlen =\r\n\t\t\t\tdcodes_huffman_bitlens[dist_deflate_code]\r\n\t\t\tWriteBits(dist_huffman_code, dist_huffman_bitlen)\r\n\r\n\t\t\tif dist_deflate_code > 3 then -- dist code with extra bits\r\n\t\t\t\tdist_code_with_extra_count = dist_code_with_extra_count + 1\r\n\t\t\t\tlocal dist_extra_bits = dextra_bits[dist_code_with_extra_count]\r\n\t\t\t\tlocal dist_extra_bits_bitlen =\r\n\t\t\t\t\t(dist_deflate_code-dist_deflate_code%2)/2 - 1\r\n\t\t\t\tWriteBits(dist_extra_bits, dist_extra_bits_bitlen)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n-- Get the size of fixed block without writing any bits into the writer.\r\n-- @param lcodes literal/LZ77_length deflate codes\r\n-- @param decodes LZ77 distance deflate codes\r\n-- @return the bit length of the fixed block\r\nlocal function GetFixedHuffmanBlockSize(lcodes, dcodes)\r\n\tlocal block_bitlen = 3\r\n\tlocal length_code_count = 0\r\n\tfor i=1, #lcodes do\r\n\t\tlocal code = lcodes[i]\r\n\t\tlocal huffman_bitlen = _fix_block_literal_huffman_bitlen[code]\r\n\t\tblock_bitlen = block_bitlen + huffman_bitlen\r\n\t\tif code > 256 then -- Length code\r\n\t\t\tlength_code_count = length_code_count + 1\r\n\t\t\tif code > 264 and code < 285 then -- Length code with extra bits\r\n\t\t\t\tlocal extra_bits_bitlen =\r\n\t\t\t\t\t_literal_deflate_code_to_extra_bitlen[code-256]\r\n\t\t\t\tblock_bitlen = block_bitlen + extra_bits_bitlen\r\n\t\t\tend\r\n\t\t\tlocal dist_code = dcodes[length_code_count]\r\n\t\t\tblock_bitlen = block_bitlen + 5\r\n\r\n\t\t\tif dist_code > 3 then -- dist code with extra bits\r\n\t\t\t\tlocal dist_extra_bits_bitlen =\r\n\t\t\t\t\t(dist_code-dist_code%2)/2 - 1\r\n\t\t\t\tblock_bitlen = block_bitlen + dist_extra_bits_bitlen\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn block_bitlen\r\nend\r\n\r\n-- Write fixed block.\r\n-- @param lcodes literal/LZ77_length deflate codes\r\n-- @param decodes LZ77 distance deflate codes\r\nlocal function CompressFixedHuffmanBlock(WriteBits, is_last_block,\r\n\t\tlcodes, lextra_bits, dcodes, dextra_bits)\r\n\tWriteBits(is_last_block and 1 or 0, 1) -- Last block identifier\r\n\tWriteBits(1, 2) -- Fixed Huffman block identifier\r\n\tlocal length_code_count = 0\r\n\tlocal length_code_with_extra_count = 0\r\n\tlocal dist_code_with_extra_count = 0\r\n\tfor i=1, #lcodes do\r\n\t\tlocal deflate_code = lcodes[i]\r\n\t\tlocal huffman_code = _fix_block_literal_huffman_code[deflate_code]\r\n\t\tlocal huffman_bitlen = _fix_block_literal_huffman_bitlen[deflate_code]\r\n\t\tWriteBits(huffman_code, huffman_bitlen)\r\n\t\tif deflate_code > 256 then -- Length code\r\n\t\t\tlength_code_count = length_code_count + 1\r\n\t\t\tif deflate_code > 264 and deflate_code < 285 then\r\n\t\t\t\t-- Length code with extra bits\r\n\t\t\t\tlength_code_with_extra_count = length_code_with_extra_count + 1\r\n\t\t\t\tlocal extra_bits = lextra_bits[length_code_with_extra_count]\r\n\t\t\t\tlocal extra_bits_bitlen =\r\n\t\t\t\t\t_literal_deflate_code_to_extra_bitlen[deflate_code-256]\r\n\t\t\t\tWriteBits(extra_bits, extra_bits_bitlen)\r\n\t\t\tend\r\n\t\t\t-- Write distance code\r\n\t\t\tlocal dist_code = dcodes[length_code_count]\r\n\t\t\tlocal dist_huffman_code = _fix_block_dist_huffman_code[dist_code]\r\n\t\t\tWriteBits(dist_huffman_code, 5)\r\n\r\n\t\t\tif dist_code > 3 then -- dist code with extra bits\r\n\t\t\t\tdist_code_with_extra_count = dist_code_with_extra_count + 1\r\n\t\t\t\tlocal dist_extra_bits = dextra_bits[dist_code_with_extra_count]\r\n\t\t\t\tlocal dist_extra_bits_bitlen = (dist_code-dist_code%2)/2 - 1\r\n\t\t\t\tWriteBits(dist_extra_bits, dist_extra_bits_bitlen)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n-- Get the size of store block without writing any bits into the writer.\r\n-- @param block_start The start index of the origin input string\r\n-- @param block_end The end index of the origin input string\r\n-- @param Total bit lens had been written into the compressed result before,\r\n-- because store block needs to shift to byte boundary.\r\n-- @return the bit length of the fixed block\r\nlocal function GetStoreBlockSize(block_start, block_end, total_bitlen)\r\n\tassert(block_end-block_start+1 <= 65535)\r\n\tlocal block_bitlen = 3\r\n\ttotal_bitlen = total_bitlen + 3\r\n\tlocal padding_bitlen = (8-total_bitlen%8)%8\r\n\tblock_bitlen = block_bitlen + padding_bitlen\r\n\tblock_bitlen = block_bitlen + 32\r\n\tblock_bitlen = block_bitlen + (block_end - block_start + 1) * 8\r\n\treturn block_bitlen\r\nend\r\n\r\n-- Write the store block.\r\n-- @param ... lots of stuffs\r\n-- @return nil\r\nlocal function CompressStoreBlock(WriteBits, WriteString, is_last_block, str\r\n\t, block_start, block_end, total_bitlen)\r\n\tassert(block_end-block_start+1 <= 65535)\r\n\tWriteBits(is_last_block and 1 or 0, 1) -- Last block identifer.\r\n\tWriteBits(0, 2) -- Store block identifier.\r\n\ttotal_bitlen = total_bitlen + 3\r\n\tlocal padding_bitlen = (8-total_bitlen%8)%8\r\n\tif padding_bitlen > 0 then\r\n\t\tWriteBits(_pow2[padding_bitlen]-1, padding_bitlen)\r\n\tend\r\n\tlocal size = block_end - block_start + 1\r\n\tWriteBits(size, 16)\r\n\r\n\t-- Write size\'s one\'s complement\r\n\tlocal comp = (255 - size % 256) + (255 - (size-size%256)/256)*256\r\n\tWriteBits(comp, 16)\r\n\r\n\tWriteString(str:sub(block_start, block_end))\r\nend\r\n\r\n-- Do the deflate\r\n-- Currently using a simple way to determine the block size\r\n-- (This is why the compression ratio is little bit worse than zlib when\r\n-- the input size is very large\r\n-- The first block is 64KB, the following block is 32KB.\r\n-- After each block, there is a memory cleanup operation.\r\n-- This is not a fast operation, but it is needed to save memory usage, so\r\n-- the memory usage does not grow unboundly. If the data size is less than\r\n-- 64KB, then memory cleanup won\'t happen.\r\n-- This function determines whether to use store/fixed/dynamic blocks by\r\n-- calculating the block size of each block type and chooses the smallest one.\r\nlocal function Deflate(configs, WriteBits, WriteString, FlushWriter, str\r\n\t, dictionary)\r\n\tlocal string_table = {}\r\n\tlocal hash_tables = {}\r\n\tlocal is_last_block = nil\r\n\tlocal block_start\r\n\tlocal block_end\r\n\tlocal bitlen_written\r\n\tlocal total_bitlen = FlushWriter(_FLUSH_MODE_NO_FLUSH)\r\n\tlocal strlen = #str\r\n\tlocal offset\r\n\r\n\tlocal level\r\n\tlocal strategy\r\n\tif configs then\r\n\t\tif configs.level then\r\n\t\t\tlevel = configs.level\r\n\t\tend\r\n\t\tif configs.strategy then\r\n\t\t\tstrategy = configs.strategy\r\n\t\tend\r\n\tend\r\n\r\n\tif not level then\r\n\t\tif strlen < 2048 then\r\n\t\t\tlevel = 7\r\n\t\telseif strlen > 65536 then\r\n\t\t\tlevel = 3\r\n\t\telse\r\n\t\t\tlevel = 5\r\n\t\tend\r\n\tend\r\n\r\n\twhile not is_last_block do\r\n\t\tif not block_start then\r\n\t\t\tblock_start = 1\r\n\t\t\tblock_end = 64*1024 - 1\r\n\t\t\toffset = 0\r\n\t\telse\r\n\t\t\tblock_start = block_end + 1\r\n\t\t\tblock_end = block_end + 32*1024\r\n\t\t\toffset = block_start - 32*1024 - 1\r\n\t\tend\r\n\r\n\t\tif block_end >= strlen then\r\n\t\t\tblock_end = strlen\r\n\t\t\tis_last_block = true\r\n\t\telse\r\n\t\t\tis_last_block = false\r\n\t\tend\r\n\r\n\t\tlocal lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits\r\n\t\t\t, dcodes_counts\r\n\r\n\t\tlocal HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens\r\n\t\t\t, rle_codes_huffman_codes, rle_deflate_codes\r\n\t\t\t, rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t\t, dcodes_huffman_bitlens, dcodes_huffman_codes\r\n\r\n\t\tlocal dynamic_block_bitlen\r\n\t\tlocal fixed_block_bitlen\r\n\t\tlocal store_block_bitlen\r\n\r\n\t\tif level ~= 0 then\r\n\r\n\t\t\t-- GetBlockLZ77 needs block_start to block_end+3 to be loaded.\r\n\t\t\tLoadStringToTable(str, string_table, block_start, block_end + 3\r\n\t\t\t\t, offset)\r\n\t\t\tif block_start == 1 and dictionary then\r\n\t\t\t\tlocal dict_string_table = dictionary.string_table\r\n\t\t\t\tlocal dict_strlen = dictionary.strlen\r\n\t\t\t\tfor i=0, (-dict_strlen+1)<-257\r\n\t\t\t\t\tand -257 or (-dict_strlen+1), -1 do\r\n\t\t\t\t\tstring_table[i] = dict_string_table[dict_strlen+i]\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tif strategy == "huffman_only" then\r\n\t\t\t\tlcodes = {}\r\n\t\t\t\tLoadStringToTable(str, lcodes, block_start, block_end\r\n\t\t\t\t\t, block_start-1)\r\n\t\t\t\tlextra_bits = {}\r\n\t\t\t\tlcodes_counts = {}\r\n\t\t\t\tlcodes[block_end - block_start+2] = 256 -- end of block\r\n\t\t\t\tfor i=1, block_end - block_start+2 do\r\n\t\t\t\t\tlocal code = lcodes[i]\r\n\t\t\t\t\tlcodes_counts[code] = (lcodes_counts[code] or 0) + 1\r\n\t\t\t\tend\r\n\t\t\t\tdcodes = {}\r\n\t\t\t\tdextra_bits = {}\r\n\t\t\t\tdcodes_counts = {}\r\n\t\t\telse\r\n\t\t\t\tlcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits\r\n\t\t\t\t, dcodes_counts = GetBlockLZ77Result(level, string_table\r\n\t\t\t\t, hash_tables, block_start, block_end, offset, dictionary\r\n\t\t\t\t)\r\n\t\t\tend\r\n\r\n\t\t\tHLIT, HDIST, HCLEN, rle_codes_huffman_bitlens\r\n\t\t\t\t, rle_codes_huffman_codes, rle_deflate_codes\r\n\t\t\t\t, rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t\t\t, dcodes_huffman_bitlens, dcodes_huffman_codes =\r\n\t\t\t\tGetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)\r\n\t\t\tdynamic_block_bitlen = GetDynamicHuffmanBlockSize(\r\n\t\t\t\t\tlcodes, dcodes, HCLEN, rle_codes_huffman_bitlens\r\n\t\t\t\t\t, rle_deflate_codes, lcodes_huffman_bitlens\r\n\t\t\t\t\t, dcodes_huffman_bitlens)\r\n\t\t\tfixed_block_bitlen = GetFixedHuffmanBlockSize(lcodes, dcodes)\r\n\t\tend\r\n\r\n\t\tstore_block_bitlen = GetStoreBlockSize(block_start, block_end\r\n\t\t\t, total_bitlen)\r\n\r\n\t\tlocal min_bitlen = store_block_bitlen\r\n\t\tmin_bitlen = (fixed_block_bitlen and fixed_block_bitlen < min_bitlen)\r\n\t\t\tand fixed_block_bitlen or min_bitlen\r\n\t\tmin_bitlen = (dynamic_block_bitlen\r\n\t\t\tand dynamic_block_bitlen < min_bitlen)\r\n\t\t\tand dynamic_block_bitlen or min_bitlen\r\n\r\n\t\tif level == 0 or (strategy ~= "fixed" and strategy ~= "dynamic" and\r\n\t\t\tstore_block_bitlen == min_bitlen) then\r\n\t\t\tCompressStoreBlock(WriteBits, WriteString, is_last_block\r\n\t\t\t\t, str, block_start, block_end, total_bitlen)\r\n\t\t\ttotal_bitlen = total_bitlen + store_block_bitlen\r\n\t\telseif strategy ~= "dynamic" and (\r\n\t\t\tstrategy == "fixed" or fixed_block_bitlen == min_bitlen) then\r\n\t\t\tCompressFixedHuffmanBlock(WriteBits, is_last_block,\r\n\t\t\t\t\tlcodes, lextra_bits, dcodes, dextra_bits)\r\n\t\t\ttotal_bitlen = total_bitlen + fixed_block_bitlen\r\n\t\telseif strategy == "dynamic" or dynamic_block_bitlen == min_bitlen then\r\n\t\t\tCompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes\r\n\t\t\t\t, lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN\r\n\t\t\t\t, rle_codes_huffman_bitlens, rle_codes_huffman_codes\r\n\t\t\t\t, rle_deflate_codes, rle_extra_bits\r\n\t\t\t\t, lcodes_huffman_bitlens, lcodes_huffman_codes\r\n\t\t\t\t, dcodes_huffman_bitlens, dcodes_huffman_codes)\r\n\t\t\ttotal_bitlen = total_bitlen + dynamic_block_bitlen\r\n\t\tend\r\n\r\n\t\tif is_last_block then\r\n\t\t\tbitlen_written = FlushWriter(_FLUSH_MODE_NO_FLUSH)\r\n\t\telse\r\n\t\t\tbitlen_written = FlushWriter(_FLUSH_MODE_MEMORY_CLEANUP)\r\n\t\tend\r\n\r\n\t\tassert(bitlen_written == total_bitlen)\r\n\r\n\t\t-- Memory clean up, so memory consumption does not always grow linearly\r\n\t\t-- , even if input string is > 64K.\r\n\t\t-- Not a very efficient operation, but this operation won\'t happen\r\n\t\t-- when the input data size is less than 64K.\r\n\t\tif not is_last_block then\r\n\t\t\tlocal j\r\n\t\t\tif dictionary and block_start == 1 then\r\n\t\t\t\tj = 0\r\n\t\t\t\twhile (string_table[j]) do\r\n\t\t\t\t\tstring_table[j] = nil\r\n\t\t\t\t\tj = j - 1\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\tdictionary = nil\r\n\t\t\tj = 1\r\n\t\t\tfor i = block_end-32767, block_end do\r\n\t\t\t\tstring_table[j] = string_table[i-offset]\r\n\t\t\t\tj = j + 1\r\n\t\t\tend\r\n\r\n\t\t\tfor k, t in pairs(hash_tables) do\r\n\t\t\t\tlocal tSize = #t\r\n\t\t\t\tif tSize > 0 and block_end+1 - t[1] > 32768 then\r\n\t\t\t\t\tif tSize == 1 then\r\n\t\t\t\t\t\thash_tables[k] = nil\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlocal new = {}\r\n\t\t\t\t\t\tlocal newSize = 0\r\n\t\t\t\t\t\tfor i = 2, tSize do\r\n\t\t\t\t\t\t\tj = t[i]\r\n\t\t\t\t\t\t\tif block_end+1 - j <= 32768 then\r\n\t\t\t\t\t\t\t\tnewSize = newSize + 1\r\n\t\t\t\t\t\t\t\tnew[newSize] = j\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t\thash_tables[k] = new\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--- The description to compression configuration table. <br>\r\n-- Any field can be nil to use its default. <br>\r\n-- Table with keys other than those below is an invalid table.\r\n-- @class table\r\n-- @name compression_configs\r\n-- @field level The compression level ranged from 0 to 9. 0 is no compression.\r\n-- 9 is the slowest but best compression. Use nil for default level.\r\n-- @field strategy The compression strategy. "fixed" to only use fixed deflate\r\n-- compression block. "dynamic" to only use dynamic block. "huffman_only" to\r\n-- do no LZ77 compression. Only do huffman compression.\r\n\r\n\r\n-- @see LibDeflate:CompressDeflate(str, configs)\r\n-- @see LibDeflate:CompressDeflateWithDict(str, dictionary, configs)\r\nlocal function CompressDeflateInternal(str, dictionary, configs)\r\n\tlocal WriteBits, WriteString, FlushWriter = CreateWriter()\r\n\tDeflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)\r\n\tlocal total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)\r\n\tlocal padding_bitlen = (8-total_bitlen%8)%8\r\n\treturn result, padding_bitlen\r\nend\r\n\r\n-- @see LibDeflate:CompressZlib\r\n-- @see LibDeflate:CompressZlibWithDict\r\nlocal function CompressZlibInternal(str, dictionary, configs)\r\n\tlocal WriteBits, WriteString, FlushWriter = CreateWriter()\r\n\r\n\tlocal CM = 8 -- Compression method\r\n\tlocal CINFO = 7 --Window Size = 32K\r\n\tlocal CMF = CINFO*16+CM\r\n\tWriteBits(CMF, 8)\r\n\r\n\tlocal FDIST = dictionary and 1 or 0\r\n\tlocal FLEVEL = 2 -- Default compression\r\n\tlocal FLG = FLEVEL*64+FDIST*32\r\n\tlocal FCHECK = (31-(CMF*256+FLG)%31)\r\n\t-- The FCHECK value must be such that CMF and FLG,\r\n\t-- when viewed as a 16-bit unsigned integer stored\r\n\t-- in MSB order (CMF*256 + FLG), is a multiple of 31.\r\n\tFLG = FLG + FCHECK\r\n\tWriteBits(FLG, 8)\r\n\r\n\tif FDIST == 1 then\r\n\t\tlocal adler32 = dictionary.adler32\r\n\t\tlocal byte0 = adler32 % 256\r\n\t\tadler32 = (adler32 - byte0) / 256\r\n\t\tlocal byte1 = adler32 % 256\r\n\t\tadler32 = (adler32 - byte1) / 256\r\n\t\tlocal byte2 = adler32 % 256\r\n\t\tadler32 = (adler32 - byte2) / 256\r\n\t\tlocal byte3 = adler32 % 256\r\n\t\tWriteBits(byte3, 8)\r\n\t\tWriteBits(byte2, 8)\r\n\t\tWriteBits(byte1, 8)\r\n\t\tWriteBits(byte0, 8)\r\n\tend\r\n\r\n\tDeflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)\r\n\tFlushWriter(_FLUSH_MODE_BYTE_BOUNDARY)\r\n\r\n\tlocal adler32 = LibDeflate:Adler32(str)\r\n\r\n\t-- Most significant byte first\r\n\tlocal byte3 = adler32%256\r\n\tadler32 = (adler32 - byte3) / 256\r\n\tlocal byte2 = adler32%256\r\n\tadler32 = (adler32 - byte2) / 256\r\n\tlocal byte1 = adler32%256\r\n\tadler32 = (adler32 - byte1) / 256\r\n\tlocal byte0 = adler32%256\r\n\r\n\tWriteBits(byte0, 8)\r\n\tWriteBits(byte1, 8)\r\n\tWriteBits(byte2, 8)\r\n\tWriteBits(byte3, 8)\r\n\tlocal total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)\r\n\tlocal padding_bitlen = (8-total_bitlen%8)%8\r\n\treturn result, padding_bitlen\r\nend\r\n\r\n--- Compress using the raw deflate format.\r\n-- @param str [string] The data to be compressed.\r\n-- @param configs [table/nil] The configuration table to control the compression\r\n-- . If nil, use the default configuration.\r\n-- @return [string] The compressed data.\r\n-- @return [integer] The number of bits padded at the end of output.\r\n-- 0 <= bits < 8  <br>\r\n-- This means the most significant "bits" of the last byte of the returned\r\n-- compressed data are padding bits and they don\'t affect decompression.\r\n-- You don\'t need to use this value unless you want to do some postprocessing\r\n-- to the compressed data.\r\n-- @see compression_configs\r\n-- @see LibDeflate:DecompressDeflate\r\nfunction LibDeflate:CompressDeflate(str, configs)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:CompressDeflate(str, configs): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn CompressDeflateInternal(str, nil, configs)\r\nend\r\n\r\n--- Compress using the raw deflate format with a preset dictionary.\r\n-- @param str [string] The data to be compressed.\r\n-- @param dictionary [table] The preset dictionary produced by\r\n-- LibDeflate:CreateDictionary\r\n-- @param configs [table/nil] The configuration table to control the compression\r\n-- . If nil, use the default configuration.\r\n-- @return [string] The compressed data.\r\n-- @return [integer] The number of bits padded at the end of output.\r\n-- 0 <= bits < 8  <br>\r\n-- This means the most significant "bits" of the last byte of the returned\r\n-- compressed data are padding bits and they don\'t affect decompression.\r\n-- You don\'t need to use this value unless you want to do some postprocessing\r\n-- to the compressed data.\r\n-- @see compression_configs\r\n-- @see LibDeflate:CreateDictionary\r\n-- @see LibDeflate:DecompressDeflateWithDict\r\nfunction LibDeflate:CompressDeflateWithDict(str, dictionary, configs)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, true, dictionary\r\n\t\t, true, configs)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:CompressDeflateWithDict"\r\n\t\t\t.."(str, dictionary, configs): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn CompressDeflateInternal(str, dictionary, configs)\r\nend\r\n\r\n--- Compress using the zlib format.\r\n-- @param str [string] the data to be compressed.\r\n-- @param configs [table/nil] The configuration table to control the compression\r\n-- . If nil, use the default configuration.\r\n-- @return [string] The compressed data.\r\n-- @return [integer] The number of bits padded at the end of output.\r\n-- Should always be 0.\r\n-- Zlib formatted compressed data never has padding bits at the end.\r\n-- @see compression_configs\r\n-- @see LibDeflate:DecompressZlib\r\nfunction LibDeflate:CompressZlib(str, configs)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:CompressZlib(str, configs): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn CompressZlibInternal(str, nil, configs)\r\nend\r\n\r\n--- Compress using the zlib format with a preset dictionary.\r\n-- @param str [string] the data to be compressed.\r\n-- @param dictionary [table] A preset dictionary produced\r\n-- by LibDeflate:CreateDictionary()\r\n-- @param configs [table/nil] The configuration table to control the compression\r\n-- . If nil, use the default configuration.\r\n-- @return [string] The compressed data.\r\n-- @return [integer] The number of bits padded at the end of output.\r\n-- Should always be 0.\r\n-- Zlib formatted compressed data never has padding bits at the end.\r\n-- @see compression_configs\r\n-- @see LibDeflate:CreateDictionary\r\n-- @see LibDeflate:DecompressZlibWithDict\r\nfunction LibDeflate:CompressZlibWithDict(str, dictionary, configs)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, true, dictionary\r\n\t\t, true, configs)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:CompressZlibWithDict"\r\n\t\t\t.."(str, dictionary, configs): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn CompressZlibInternal(str, dictionary, configs)\r\nend\r\n\r\n--[[ --------------------------------------------------------------------------\r\n\tDecompress code\r\n--]] --------------------------------------------------------------------------\r\n\r\n--[[\r\n\tCreate a reader to easily reader stuffs as the unit of bits.\r\n\tReturn values:\r\n\t1. ReadBits(bitlen)\r\n\t2. ReadBytes(bytelen, buffer, buffer_size)\r\n\t3. Decode(huffman_bitlen_count, huffman_symbol, min_bitlen)\r\n\t4. ReaderBitlenLeft()\r\n\t5. SkipToByteBoundary()\r\n--]]\r\nlocal function CreateReader(input_string)\r\n\tlocal input = input_string\r\n\tlocal input_strlen = #input_string\r\n\tlocal input_next_byte_pos = 1\r\n\tlocal cache_bitlen = 0\r\n\tlocal cache = 0\r\n\r\n\t-- Read some bits.\r\n\t-- To improve speed, this function does not\r\n\t-- check if the input has been exhausted.\r\n\t-- Use ReaderBitlenLeft() < 0 to check it.\r\n\t-- @param bitlen the number of bits to read\r\n\t-- @return the data is read.\r\n\tlocal function ReadBits(bitlen)\r\n\t\tlocal rshift_mask = _pow2[bitlen]\r\n\t\tlocal code\r\n\t\tif bitlen <= cache_bitlen then\r\n\t\t\tcode = cache % rshift_mask\r\n\t\t\tcache = (cache - code) / rshift_mask\r\n\t\t\tcache_bitlen = cache_bitlen - bitlen\r\n\t\telse -- Whether input has been exhausted is not checked.\r\n\t\t\tlocal lshift_mask = _pow2[cache_bitlen]\r\n\t\t\tlocal byte1, byte2, byte3, byte4 = string_byte(input\r\n\t\t\t\t, input_next_byte_pos, input_next_byte_pos+3)\r\n\t\t\t-- This requires lua number to be at least double ()\r\n\t\t\tcache = cache + ((byte1 or 0)+(byte2 or 0)*256\r\n\t\t\t\t+ (byte3 or 0)*65536+(byte4 or 0)*16777216)*lshift_mask\r\n\t\t\tinput_next_byte_pos = input_next_byte_pos + 4\r\n\t\t\tcache_bitlen = cache_bitlen + 32 - bitlen\r\n\t\t\tcode = cache % rshift_mask\r\n\t\t\tcache = (cache - code) / rshift_mask\r\n\t\tend\r\n\t\treturn code\r\n\tend\r\n\r\n\t-- Read some bytes from the reader.\r\n\t-- Assume reader is on the byte boundary.\r\n\t-- @param bytelen The number of bytes to be read.\r\n\t-- @param buffer The byte read will be stored into this buffer.\r\n\t-- @param buffer_size The buffer will be modified starting from\r\n\t--\tbuffer[buffer_size+1], ending at buffer[buffer_size+bytelen-1]\r\n\t-- @return the new buffer_size\r\n\tlocal function ReadBytes(bytelen, buffer, buffer_size)\r\n\t\tassert(cache_bitlen % 8 == 0)\r\n\r\n\t\tlocal byte_from_cache = (cache_bitlen/8 < bytelen)\r\n\t\t\tand (cache_bitlen/8) or bytelen\r\n\t\tfor _=1, byte_from_cache do\r\n\t\t\tlocal byte = cache % 256\r\n\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\tbuffer[buffer_size] = string_char(byte)\r\n\t\t\tcache = (cache - byte) / 256\r\n\t\tend\r\n\t\tcache_bitlen = cache_bitlen - byte_from_cache*8\r\n\t\tbytelen = bytelen - byte_from_cache\r\n\t\tif (input_strlen - input_next_byte_pos - bytelen + 1) * 8\r\n\t\t\t+ cache_bitlen < 0 then\r\n\t\t\treturn -1 -- out of input\r\n\t\tend\r\n\t\tfor i=input_next_byte_pos, input_next_byte_pos+bytelen-1 do\r\n\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\tbuffer[buffer_size] = string_sub(input, i, i)\r\n\t\tend\r\n\r\n\t\tinput_next_byte_pos = input_next_byte_pos + bytelen\r\n\t\treturn buffer_size\r\n\tend\r\n\r\n\t-- Decode huffman code\r\n\t-- To improve speed, this function does not check\r\n\t-- if the input has been exhausted.\r\n\t-- Use ReaderBitlenLeft() < 0 to check it.\r\n\t-- Credits for Mark Adler. This code is from puff:Decode()\r\n\t-- @see puff:Decode(...)\r\n\t-- @param huffman_bitlen_count\r\n\t-- @param huffman_symbol\r\n\t-- @param min_bitlen The minimum huffman bit length of all symbols\r\n\t-- @return The decoded deflate code.\r\n\t--\tNegative value is returned if decoding fails.\r\n\tlocal function Decode(huffman_bitlen_counts, huffman_symbols, min_bitlen)\r\n\t\tlocal code = 0\r\n\t\tlocal first = 0\r\n\t\tlocal index = 0\r\n\t\tlocal count\r\n\t\tif min_bitlen > 0 then\r\n\t\t\tif cache_bitlen < 15 and input then\r\n\t\t\t\tlocal lshift_mask = _pow2[cache_bitlen]\r\n\t\t\t\tlocal byte1, byte2, byte3, byte4 =\r\n\t\t\t\t\tstring_byte(input, input_next_byte_pos\r\n\t\t\t\t\t, input_next_byte_pos+3)\r\n\t\t\t\t-- This requires lua number to be at least double ()\r\n\t\t\t\tcache = cache + ((byte1 or 0)+(byte2 or 0)*256\r\n\t\t\t\t\t+(byte3 or 0)*65536+(byte4 or 0)*16777216)*lshift_mask\r\n\t\t\t\tinput_next_byte_pos = input_next_byte_pos + 4\r\n\t\t\t\tcache_bitlen = cache_bitlen + 32\r\n\t\t\tend\r\n\r\n\t\t\tlocal rshift_mask = _pow2[min_bitlen]\r\n\t\t\tcache_bitlen = cache_bitlen - min_bitlen\r\n\t\t\tcode = cache % rshift_mask\r\n\t\t\tcache = (cache - code) / rshift_mask\r\n\t\t\t-- Reverse the bits\r\n\t\t\tcode = _reverse_bits_tbl[min_bitlen][code]\r\n\r\n\t\t\tcount = huffman_bitlen_counts[min_bitlen]\r\n\t\t\tif code < count then\r\n\t\t\t\treturn huffman_symbols[code]\r\n\t\t\tend\r\n\t\t\tindex = count\r\n\t\t\tfirst = count * 2\r\n\t\t\tcode = code * 2\r\n\t\tend\r\n\r\n\t\tfor bitlen = min_bitlen+1, 15 do\r\n\t\t\tlocal bit\r\n\t\t\tbit = cache % 2\r\n\t\t\tcache = (cache - bit) / 2\r\n\t\t\tcache_bitlen = cache_bitlen - 1\r\n\r\n\t\t\tcode = (bit==1) and (code + 1 - code % 2) or code\r\n\t\t\tcount = huffman_bitlen_counts[bitlen] or 0\r\n\t\t\tlocal diff = code - first\r\n\t\t\tif diff < count then\r\n\t\t\t\treturn huffman_symbols[index + diff]\r\n\t\t\tend\r\n\t\t\tindex = index + count\r\n\t\t\tfirst = first + count\r\n\t\t\tfirst = first * 2\r\n\t\t\tcode = code * 2\r\n\t\tend\r\n\t\t-- invalid literal/length or distance code\r\n\t\t-- in fixed or dynamic block (run out of code)\r\n\t\treturn -10\r\n\tend\r\n\r\n\tlocal function ReaderBitlenLeft()\r\n\t\treturn (input_strlen - input_next_byte_pos + 1) * 8 + cache_bitlen\r\n\tend\r\n\r\n\tlocal function SkipToByteBoundary()\r\n\t\tlocal skipped_bitlen = cache_bitlen%8\r\n\t\tlocal rshift_mask = _pow2[skipped_bitlen]\r\n\t\tcache_bitlen = cache_bitlen - skipped_bitlen\r\n\t\tcache = (cache - cache % rshift_mask) / rshift_mask\r\n\tend\r\n\r\n\treturn ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary\r\nend\r\n\r\n-- Create a deflate state, so I can pass in less arguments to functions.\r\n-- @param str the whole string to be decompressed.\r\n-- @param dictionary The preset dictionary. nil if not provided.\r\n--\t\tThis dictionary should be produced by LibDeflate:CreateDictionary(str)\r\n-- @return The decomrpess state.\r\nlocal function CreateDecompressState(str, dictionary)\r\n\tlocal ReadBits, ReadBytes, Decode, ReaderBitlenLeft\r\n\t\t, SkipToByteBoundary = CreateReader(str)\r\n\tlocal state =\r\n\t{\r\n\t\tReadBits = ReadBits,\r\n\t\tReadBytes = ReadBytes,\r\n\t\tDecode = Decode,\r\n\t\tReaderBitlenLeft = ReaderBitlenLeft,\r\n\t\tSkipToByteBoundary = SkipToByteBoundary,\r\n\t\tbuffer_size = 0,\r\n\t\tbuffer = {},\r\n\t\tresult_buffer = {},\r\n\t\tdictionary = dictionary,\r\n\t}\r\n\treturn state\r\nend\r\n\r\n-- Get the stuffs needed to decode huffman codes\r\n-- @see puff.c:construct(...)\r\n-- @param huffman_bitlen The huffman bit length of the huffman codes.\r\n-- @param max_symbol The maximum symbol\r\n-- @param max_bitlen The min huffman bit length of all codes\r\n-- @return zero or positive for success, negative for failure.\r\n-- @return The count of each huffman bit length.\r\n-- @return A table to convert huffman codes to deflate codes.\r\n-- @return The minimum huffman bit length.\r\nlocal function GetHuffmanForDecode(huffman_bitlens, max_symbol, max_bitlen)\r\n\tlocal huffman_bitlen_counts = {}\r\n\tlocal min_bitlen = max_bitlen\r\n\tfor symbol = 0, max_symbol do\r\n\t\tlocal bitlen = huffman_bitlens[symbol] or 0\r\n\t\tmin_bitlen = (bitlen > 0 and bitlen < min_bitlen)\r\n\t\t\tand bitlen or min_bitlen\r\n\t\thuffman_bitlen_counts[bitlen] = (huffman_bitlen_counts[bitlen] or 0)+1\r\n\tend\r\n\r\n\tif huffman_bitlen_counts[0] == max_symbol+1 then -- No Codes\r\n\t\treturn 0, huffman_bitlen_counts, {}, 0 -- Complete, but decode will fail\r\n\tend\r\n\r\n\tlocal left = 1\r\n\tfor len = 1, max_bitlen do\r\n\t\tleft = left * 2\r\n\t\tleft = left - (huffman_bitlen_counts[len] or 0)\r\n\t\tif left < 0 then\r\n\t\t\treturn left -- Over-subscribed, return negative\r\n\t\tend\r\n\tend\r\n\r\n\t-- Generate offsets info symbol table for each length for sorting\r\n\tlocal offsets = {}\r\n\toffsets[1] = 0\r\n\tfor len = 1, max_bitlen-1 do\r\n\t\toffsets[len + 1] = offsets[len] + (huffman_bitlen_counts[len] or 0)\r\n\tend\r\n\r\n\tlocal huffman_symbols = {}\r\n\tfor symbol = 0, max_symbol do\r\n\t\tlocal bitlen = huffman_bitlens[symbol] or 0\r\n\t\tif bitlen ~= 0 then\r\n\t\t\tlocal offset = offsets[bitlen]\r\n\t\t\thuffman_symbols[offset] = symbol\r\n\t\t\toffsets[bitlen] = offsets[bitlen] + 1\r\n\t\tend\r\n\tend\r\n\r\n\t-- Return zero for complete set, positive for incomplete set.\r\n\treturn left, huffman_bitlen_counts, huffman_symbols, min_bitlen\r\nend\r\n\r\n-- Decode a fixed or dynamic huffman blocks, excluding last block identifier\r\n-- and block type identifer.\r\n-- @see puff.c:codes()\r\n-- @param state decompression state that will be modified by this function.\r\n--\t@see CreateDecompressState\r\n-- @param ... Read the source code\r\n-- @return 0 on success, other value on failure.\r\nlocal function DecodeUntilEndOfBlock(state, lcodes_huffman_bitlens\r\n\t, lcodes_huffman_symbols, lcodes_huffman_min_bitlen\r\n\t, dcodes_huffman_bitlens, dcodes_huffman_symbols\r\n\t, dcodes_huffman_min_bitlen)\r\n\tlocal buffer, buffer_size, ReadBits, Decode, ReaderBitlenLeft\r\n\t\t, result_buffer =\r\n\t\tstate.buffer, state.buffer_size, state.ReadBits, state.Decode\r\n\t\t, state.ReaderBitlenLeft, state.result_buffer\r\n\tlocal dictionary = state.dictionary\r\n\tlocal dict_string_table\r\n\tlocal dict_strlen\r\n\r\n\tlocal buffer_end = 1\r\n\tif dictionary and not buffer[0] then\r\n\t\t-- If there is a dictionary, copy the last 258 bytes into\r\n\t\t-- the string_table to make the copy in the main loop quicker.\r\n\t\t-- This is done only once per decompression.\r\n\t\tdict_string_table = dictionary.string_table\r\n\t\tdict_strlen = dictionary.strlen\r\n\t\tbuffer_end = -dict_strlen + 1\r\n\t\tfor i=0, (-dict_strlen+1)<-257 and -257 or (-dict_strlen+1), -1 do\r\n\t\t\tbuffer[i] = _byte_to_char[dict_string_table[dict_strlen+i]]\r\n\t\tend\r\n\tend\r\n\r\n\trepeat\r\n\t\tlocal symbol = Decode(lcodes_huffman_bitlens\r\n\t\t\t, lcodes_huffman_symbols, lcodes_huffman_min_bitlen)\r\n\t\tif symbol < 0 or symbol > 285 then\r\n\t\t-- invalid literal/length or distance code in fixed or dynamic block\r\n\t\t\treturn -10\r\n\t\telseif symbol < 256 then -- Literal\r\n\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\tbuffer[buffer_size] = _byte_to_char[symbol]\r\n\t\telseif symbol > 256 then -- Length code\r\n\t\t\tsymbol = symbol - 256\r\n\t\t\tlocal bitlen = _literal_deflate_code_to_base_len[symbol]\r\n\t\t\tbitlen = (symbol >= 8)\r\n\t\t\t\t and (bitlen\r\n\t\t\t\t + ReadBits(_literal_deflate_code_to_extra_bitlen[symbol]))\r\n\t\t\t\t\tor bitlen\r\n\t\t\tsymbol = Decode(dcodes_huffman_bitlens, dcodes_huffman_symbols\r\n\t\t\t\t, dcodes_huffman_min_bitlen)\r\n\t\t\tif symbol < 0 or symbol > 29 then\r\n\t\t\t-- invalid literal/length or distance code in fixed or dynamic block\r\n\t\t\t\treturn -10\r\n\t\t\tend\r\n\t\t\tlocal dist = _dist_deflate_code_to_base_dist[symbol]\r\n\t\t\tdist = (dist > 4) and (dist\r\n\t\t\t\t+ ReadBits(_dist_deflate_code_to_extra_bitlen[symbol])) or dist\r\n\r\n\t\t\tlocal char_buffer_index = buffer_size-dist+1\r\n\t\t\tif char_buffer_index < buffer_end then\r\n\t\t\t-- distance is too far back in fixed or dynamic block\r\n\t\t\t\treturn -11\r\n\t\t\tend\r\n\t\t\tif char_buffer_index >= -257 then\r\n\t\t\t\tfor _=1, bitlen do\r\n\t\t\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\t\t\tbuffer[buffer_size] = buffer[char_buffer_index]\r\n\t\t\t\t\tchar_buffer_index = char_buffer_index + 1\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tchar_buffer_index = dict_strlen + char_buffer_index\r\n\t\t\t\tfor _=1, bitlen do\r\n\t\t\t\t\tbuffer_size = buffer_size + 1\r\n\t\t\t\t\tbuffer[buffer_size] =\r\n\t\t\t\t\t_byte_to_char[dict_string_table[char_buffer_index]]\r\n\t\t\t\t\tchar_buffer_index = char_buffer_index + 1\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif ReaderBitlenLeft() < 0 then\r\n\t\t\treturn 2 -- available inflate data did not terminate\r\n\t\tend\r\n\r\n\t\tif buffer_size >= 65536 then\r\n\t\t\tresult_buffer[#result_buffer+1] =\r\n\t\t\t\ttable_concat(buffer, "", 1, 32768)\r\n\t\t\tfor i=32769, buffer_size do\r\n\t\t\t\tbuffer[i-32768] = buffer[i]\r\n\t\t\tend\r\n\t\t\tbuffer_size = buffer_size - 32768\r\n\t\t\tbuffer[buffer_size+1] = nil\r\n\t\t\t-- NOTE: buffer[32769..end] and buffer[-257..0] are not cleared.\r\n\t\t\t-- This is why "buffer_size" variable is needed.\r\n\t\tend\r\n\tuntil symbol == 256\r\n\r\n\tstate.buffer_size = buffer_size\r\n\r\n\treturn 0\r\nend\r\n\r\n-- Decompress a store block\r\n-- @param state decompression state that will be modified by this function.\r\n-- @return 0 if succeeds, other value if fails.\r\nlocal function DecompressStoreBlock(state)\r\n\tlocal buffer, buffer_size, ReadBits, ReadBytes, ReaderBitlenLeft\r\n\t\t, SkipToByteBoundary, result_buffer =\r\n\t\tstate.buffer, state.buffer_size, state.ReadBits, state.ReadBytes\r\n\t\t, state.ReaderBitlenLeft, state.SkipToByteBoundary, state.result_buffer\r\n\r\n\tSkipToByteBoundary()\r\n\tlocal bytelen = ReadBits(16)\r\n\tif ReaderBitlenLeft() < 0 then\r\n\t\treturn 2 -- available inflate data did not terminate\r\n\tend\r\n\tlocal bytelenComp = ReadBits(16)\r\n\tif ReaderBitlenLeft() < 0 then\r\n\t\treturn 2 -- available inflate data did not terminate\r\n\tend\r\n\r\n\tif bytelen % 256 + bytelenComp % 256 ~= 255 then\r\n\t\treturn -2 -- Not one\'s complement\r\n\tend\r\n\tif (bytelen-bytelen % 256)/256\r\n\t\t+ (bytelenComp-bytelenComp % 256)/256 ~= 255 then\r\n\t\treturn -2 -- Not one\'s complement\r\n\tend\r\n\r\n\t-- Note that ReadBytes will skip to the next byte boundary first.\r\n\tbuffer_size = ReadBytes(bytelen, buffer, buffer_size)\r\n\tif buffer_size < 0 then\r\n\t\treturn 2 -- available inflate data did not terminate\r\n\tend\r\n\r\n\t-- memory clean up when there are enough bytes in the buffer.\r\n\tif buffer_size >= 65536 then\r\n\t\tresult_buffer[#result_buffer+1] = table_concat(buffer, "", 1, 32768)\r\n\t\tfor i=32769, buffer_size do\r\n\t\t\tbuffer[i-32768] = buffer[i]\r\n\t\tend\r\n\t\tbuffer_size = buffer_size - 32768\r\n\t\tbuffer[buffer_size+1] = nil\r\n\tend\r\n\tstate.buffer_size = buffer_size\r\n\treturn 0\r\nend\r\n\r\n-- Decompress a fixed block\r\n-- @param state decompression state that will be modified by this function.\r\n-- @return 0 if succeeds other value if fails.\r\nlocal function DecompressFixBlock(state)\r\n\treturn DecodeUntilEndOfBlock(state\r\n\t\t, _fix_block_literal_huffman_bitlen_count\r\n\t\t, _fix_block_literal_huffman_to_deflate_code, 7\r\n\t\t, _fix_block_dist_huffman_bitlen_count\r\n\t\t, _fix_block_dist_huffman_to_deflate_code, 5)\r\nend\r\n\r\n-- Decompress a dynamic block\r\n-- @param state decompression state that will be modified by this function.\r\n-- @return 0 if success, other value if fails.\r\nlocal function DecompressDynamicBlock(state)\r\n\tlocal ReadBits, Decode = state.ReadBits, state.Decode\r\n\tlocal nlen = ReadBits(5) + 257\r\n\tlocal ndist = ReadBits(5) + 1\r\n\tlocal ncode = ReadBits(4) + 4\r\n\tif nlen > 286 or ndist > 30 then\r\n\t\t-- dynamic block code description: too many length or distance codes\r\n\t\treturn -3\r\n\tend\r\n\r\n\tlocal rle_codes_huffman_bitlens = {}\r\n\r\n\tfor i = 1, ncode do\r\n\t\trle_codes_huffman_bitlens[_rle_codes_huffman_bitlen_order[i]] =\r\n\t\t\tReadBits(3)\r\n\tend\r\n\r\n\tlocal rle_codes_err, rle_codes_huffman_bitlen_counts,\r\n\t\trle_codes_huffman_symbols, rle_codes_huffman_min_bitlen =\r\n\t\tGetHuffmanForDecode(rle_codes_huffman_bitlens, 18, 7)\r\n\tif rle_codes_err ~= 0 then -- Require complete code set here\r\n\t\t-- dynamic block code description: code lengths codes incomplete\r\n\t\treturn -4\r\n\tend\r\n\r\n\tlocal lcodes_huffman_bitlens = {}\r\n\tlocal dcodes_huffman_bitlens = {}\r\n\t-- Read length/literal and distance code length tables\r\n\tlocal index = 0\r\n\twhile index < nlen + ndist do\r\n\t\tlocal symbol -- Decoded value\r\n\t\tlocal bitlen -- Last length to repeat\r\n\r\n\t\tsymbol = Decode(rle_codes_huffman_bitlen_counts\r\n\t\t\t, rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen)\r\n\r\n\t\tif symbol < 0 then\r\n\t\t\treturn symbol -- Invalid symbol\r\n\t\telseif symbol < 16 then\r\n\t\t\tif index < nlen then\r\n\t\t\t\tlcodes_huffman_bitlens[index] = symbol\r\n\t\t\telse\r\n\t\t\t\tdcodes_huffman_bitlens[index-nlen] = symbol\r\n\t\t\tend\r\n\t\t\tindex = index + 1\r\n\t\telse\r\n\t\t\tbitlen = 0\r\n\t\t\tif symbol == 16 then\r\n\t\t\t\tif index == 0 then\r\n\t\t\t\t\t-- dynamic block code description: repeat lengths\r\n\t\t\t\t\t-- with no first length\r\n\t\t\t\t\treturn -5\r\n\t\t\t\tend\r\n\t\t\t\tif index-1 < nlen then\r\n\t\t\t\t\tbitlen = lcodes_huffman_bitlens[index-1]\r\n\t\t\t\telse\r\n\t\t\t\t\tbitlen = dcodes_huffman_bitlens[index-nlen-1]\r\n\t\t\t\tend\r\n\t\t\t\tsymbol = 3 + ReadBits(2)\r\n\t\t\telseif symbol == 17 then -- Repeat zero 3..10 times\r\n\t\t\t\tsymbol = 3 + ReadBits(3)\r\n\t\t\telse -- == 18, repeat zero 11.138 times\r\n\t\t\t\tsymbol = 11 + ReadBits(7)\r\n\t\t\tend\r\n\t\t\tif index + symbol > nlen + ndist then\r\n\t\t\t\t-- dynamic block code description:\r\n\t\t\t\t-- repeat more than specified lengths\r\n\t\t\t\treturn -6\r\n\t\t\tend\r\n\t\t\twhile symbol > 0 do -- Repeat last or zero symbol times\r\n\t\t\t\tsymbol = symbol - 1\r\n\t\t\t\tif index < nlen then\r\n\t\t\t\t\tlcodes_huffman_bitlens[index] = bitlen\r\n\t\t\t\telse\r\n\t\t\t\t\tdcodes_huffman_bitlens[index-nlen] = bitlen\r\n\t\t\t\tend\r\n\t\t\t\tindex = index + 1\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\tif (lcodes_huffman_bitlens[256] or 0) == 0 then\r\n\t\t-- dynamic block code description: missing end-of-block code\r\n\t\treturn -9\r\n\tend\r\n\r\n\tlocal lcodes_err, lcodes_huffman_bitlen_counts\r\n\t\t, lcodes_huffman_symbols, lcodes_huffman_min_bitlen =\r\n\t\tGetHuffmanForDecode(lcodes_huffman_bitlens, nlen-1, 15)\r\n\t--dynamic block code description: invalid literal/length code lengths,\r\n\t-- Incomplete code ok only for single length 1 code\r\n\tif (lcodes_err ~=0 and (lcodes_err < 0\r\n\t\tor nlen ~= (lcodes_huffman_bitlen_counts[0] or 0)\r\n\t\t\t+(lcodes_huffman_bitlen_counts[1] or 0))) then\r\n\t\treturn -7\r\n\tend\r\n\r\n\tlocal dcodes_err, dcodes_huffman_bitlen_counts\r\n\t\t, dcodes_huffman_symbols, dcodes_huffman_min_bitlen =\r\n\t\tGetHuffmanForDecode(dcodes_huffman_bitlens, ndist-1, 15)\r\n\t-- dynamic block code description: invalid distance code lengths,\r\n\t-- Incomplete code ok only for single length 1 code\r\n\tif (dcodes_err ~=0 and (dcodes_err < 0\r\n\t\tor ndist ~= (dcodes_huffman_bitlen_counts[0] or 0)\r\n\t\t\t+ (dcodes_huffman_bitlen_counts[1] or 0))) then\r\n\t\treturn -8\r\n\tend\r\n\r\n\t-- Build buffman table for literal/length codes\r\n\treturn DecodeUntilEndOfBlock(state, lcodes_huffman_bitlen_counts\r\n\t\t, lcodes_huffman_symbols, lcodes_huffman_min_bitlen\r\n\t\t, dcodes_huffman_bitlen_counts, dcodes_huffman_symbols\r\n\t\t, dcodes_huffman_min_bitlen)\r\nend\r\n\r\n-- Decompress a deflate stream\r\n-- @param state: a decompression state\r\n-- @return the decompressed string if succeeds. nil if fails.\r\nlocal function Inflate(state)\r\n\tlocal ReadBits = state.ReadBits\r\n\r\n\tlocal is_last_block\r\n\twhile not is_last_block do\r\n\t\tis_last_block = (ReadBits(1) == 1)\r\n\t\tlocal block_type = ReadBits(2)\r\n\t\tlocal status\r\n\t\tif block_type == 0 then\r\n\t\t\tstatus = DecompressStoreBlock(state)\r\n\t\telseif block_type == 1 then\r\n\t\t\tstatus = DecompressFixBlock(state)\r\n\t\telseif block_type == 2 then\r\n\t\t\tstatus = DecompressDynamicBlock(state)\r\n\t\telse\r\n\t\t\treturn nil, -1 -- invalid block type (type == 3)\r\n\t\tend\r\n\t\tif status ~= 0 then\r\n\t\t\treturn nil, status\r\n\t\tend\r\n\tend\r\n\r\n\tstate.result_buffer[#state.result_buffer+1] =\r\n\t\ttable_concat(state.buffer, "", 1, state.buffer_size)\r\n\tlocal result = table_concat(state.result_buffer)\r\n\treturn result\r\nend\r\n\r\n-- @see LibDeflate:DecompressDeflate(str)\r\n-- @see LibDeflate:DecompressDeflateWithDict(str, dictionary)\r\nlocal function DecompressDeflateInternal(str, dictionary)\r\n\tlocal state = CreateDecompressState(str, dictionary)\r\n\tlocal result, status = Inflate(state)\r\n\tif not result then\r\n\t\treturn nil, status\r\n\tend\r\n\r\n\tlocal bitlen_left = state.ReaderBitlenLeft()\r\n\tlocal bytelen_left = (bitlen_left - bitlen_left % 8) / 8\r\n\treturn result, bytelen_left\r\nend\r\n\r\n-- @see LibDeflate:DecompressZlib(str)\r\n-- @see LibDeflate:DecompressZlibWithDict(str)\r\nlocal function DecompressZlibInternal(str, dictionary)\r\n\tlocal state = CreateDecompressState(str, dictionary)\r\n\tlocal ReadBits = state.ReadBits\r\n\r\n\tlocal CMF = ReadBits(8)\r\n\tif state.ReaderBitlenLeft() < 0 then\r\n\t\treturn nil, 2 -- available inflate data did not terminate\r\n\tend\r\n\tlocal CM = CMF % 16\r\n\tlocal CINFO = (CMF - CM) / 16\r\n\tif CM ~= 8 then\r\n\t\treturn nil, -12 -- invalid compression method\r\n\tend\r\n\tif CINFO > 7 then\r\n\t\treturn nil, -13 -- invalid window size\r\n\tend\r\n\r\n\tlocal FLG = ReadBits(8)\r\n\tif state.ReaderBitlenLeft() < 0 then\r\n\t\treturn nil, 2 -- available inflate data did not terminate\r\n\tend\r\n\tif (CMF*256+FLG)%31 ~= 0 then\r\n\t\treturn nil, -14 -- invalid header checksum\r\n\tend\r\n\r\n\tlocal FDIST = ((FLG-FLG%32)/32 % 2)\r\n\tlocal FLEVEL = ((FLG-FLG%64)/64 % 4) -- luacheck: ignore FLEVEL\r\n\r\n\tif FDIST == 1 then\r\n\t\tif not dictionary then\r\n\t\t\treturn nil, -16 -- need dictonary, but dictionary is not provided.\r\n\t\tend\r\n\t\tlocal byte3 = ReadBits(8)\r\n\t\tlocal byte2 = ReadBits(8)\r\n\t\tlocal byte1 = ReadBits(8)\r\n\t\tlocal byte0 = ReadBits(8)\r\n\t\tlocal actual_adler32 = byte3*16777216+byte2*65536+byte1*256+byte0\r\n\t\tif state.ReaderBitlenLeft() < 0 then\r\n\t\t\treturn nil, 2 -- available inflate data did not terminate\r\n\t\tend\r\n\t\tif not IsEqualAdler32(actual_adler32, dictionary.adler32) then\r\n\t\t\treturn nil, -17 -- dictionary adler32 does not match\r\n\t\tend\r\n\tend\r\n\tlocal result, status = Inflate(state)\r\n\tif not result then\r\n\t\treturn nil, status\r\n\tend\r\n\tstate.SkipToByteBoundary()\r\n\r\n\tlocal adler_byte0 = ReadBits(8)\r\n\tlocal adler_byte1 = ReadBits(8)\r\n\tlocal adler_byte2 = ReadBits(8)\r\n\tlocal adler_byte3 = ReadBits(8)\r\n\tif state.ReaderBitlenLeft() < 0 then\r\n\t\treturn nil, 2 -- available inflate data did not terminate\r\n\tend\r\n\r\n\tlocal adler32_expected = adler_byte0*16777216\r\n\t\t+ adler_byte1*65536 + adler_byte2*256 + adler_byte3\r\n\tlocal adler32_actual = LibDeflate:Adler32(result)\r\n\tif not IsEqualAdler32(adler32_expected, adler32_actual) then\r\n\t\treturn nil, -15 -- Adler32 checksum does not match\r\n\tend\r\n\r\n\tlocal bitlen_left = state.ReaderBitlenLeft()\r\n\tlocal bytelen_left = (bitlen_left - bitlen_left % 8) / 8\r\n\treturn result, bytelen_left\r\nend\r\n\r\n--- Decompress a raw deflate compressed data.\r\n-- @param str [string] The data to be decompressed.\r\n-- @return [string/nil] If the decompression succeeds, return the decompressed\r\n-- data. If the decompression fails, return nil. You should check if this return\r\n-- value is non-nil to know if the decompression succeeds.\r\n-- @return [integer] If the decompression succeeds, return the number of\r\n-- unprocessed bytes in the input compressed data. This return value is a\r\n-- positive integer if the input data is a valid compressed data appended by an\r\n-- arbitary non-empty string. This return value is 0 if the input data does not\r\n-- contain any extra bytes.<br>\r\n-- If the decompression fails (The first return value of this function is nil),\r\n-- this return value is undefined.\r\n-- @see LibDeflate:CompressDeflate\r\nfunction LibDeflate:DecompressDeflate(str)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:DecompressDeflate(str): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn DecompressDeflateInternal(str)\r\nend\r\n\r\n--- Decompress a raw deflate compressed data with a preset dictionary.\r\n-- @param str [string] The data to be decompressed.\r\n-- @param dictionary [table] The preset dictionary used by\r\n-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.\r\n-- Decompression and compression must use the same dictionary.\r\n-- Otherwise wrong decompressed data could be produced without generating any\r\n-- error.\r\n-- @return [string/nil] If the decompression succeeds, return the decompressed\r\n-- data. If the decompression fails, return nil. You should check if this return\r\n-- value is non-nil to know if the decompression succeeds.\r\n-- @return [integer] If the decompression succeeds, return the number of\r\n-- unprocessed bytes in the input compressed data. This return value is a\r\n-- positive integer if the input data is a valid compressed data appended by an\r\n-- arbitary non-empty string. This return value is 0 if the input data does not\r\n-- contain any extra bytes.<br>\r\n-- If the decompression fails (The first return value of this function is nil),\r\n-- this return value is undefined.\r\n-- @see LibDeflate:CompressDeflateWithDict\r\nfunction LibDeflate:DecompressDeflateWithDict(str, dictionary)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, true, dictionary)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn DecompressDeflateInternal(str, dictionary)\r\nend\r\n\r\n--- Decompress a zlib compressed data.\r\n-- @param str [string] The data to be decompressed\r\n-- @return [string/nil] If the decompression succeeds, return the decompressed\r\n-- data. If the decompression fails, return nil. You should check if this return\r\n-- value is non-nil to know if the decompression succeeds.\r\n-- @return [integer] If the decompression succeeds, return the number of\r\n-- unprocessed bytes in the input compressed data. This return value is a\r\n-- positive integer if the input data is a valid compressed data appended by an\r\n-- arbitary non-empty string. This return value is 0 if the input data does not\r\n-- contain any extra bytes.<br>\r\n-- If the decompression fails (The first return value of this function is nil),\r\n-- this return value is undefined.\r\n-- @see LibDeflate:CompressZlib\r\nfunction LibDeflate:DecompressZlib(str)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:DecompressZlib(str): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn DecompressZlibInternal(str)\r\nend\r\n\r\n--- Decompress a zlib compressed data with a preset dictionary.\r\n-- @param str [string] The data to be decompressed\r\n-- @param dictionary [table] The preset dictionary used by\r\n-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.\r\n-- Decompression and compression must use the same dictionary.\r\n-- Otherwise wrong decompressed data could be produced without generating any\r\n-- error.\r\n-- @return [string/nil] If the decompression succeeds, return the decompressed\r\n-- data. If the decompression fails, return nil. You should check if this return\r\n-- value is non-nil to know if the decompression succeeds.\r\n-- @return [integer] If the decompression succeeds, return the number of\r\n-- unprocessed bytes in the input compressed data. This return value is a\r\n-- positive integer if the input data is a valid compressed data appended by an\r\n-- arbitary non-empty string. This return value is 0 if the input data does not\r\n-- contain any extra bytes.<br>\r\n-- If the decompression fails (The first return value of this function is nil),\r\n-- this return value is undefined.\r\n-- @see LibDeflate:CompressZlibWithDict\r\nfunction LibDeflate:DecompressZlibWithDict(str, dictionary)\r\n\tlocal arg_valid, arg_err = IsValidArguments(str, true, dictionary)\r\n\tif not arg_valid then\r\n\t\terror(("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "\r\n\t\t\t..arg_err), 2)\r\n\tend\r\n\treturn DecompressZlibInternal(str, dictionary)\r\nend\r\n\r\n-- Calculate the huffman code of fixed block\r\ndo\r\n\t_fix_block_literal_huffman_bitlen = {}\r\n\tfor sym=0, 143 do\r\n\t\t_fix_block_literal_huffman_bitlen[sym] = 8\r\n\tend\r\n\tfor sym=144, 255 do\r\n\t\t_fix_block_literal_huffman_bitlen[sym] = 9\r\n\tend\r\n\tfor sym=256, 279 do\r\n\t    _fix_block_literal_huffman_bitlen[sym] = 7\r\n\tend\r\n\tfor sym=280, 287 do\r\n\t\t_fix_block_literal_huffman_bitlen[sym] = 8\r\n\tend\r\n\r\n\t_fix_block_dist_huffman_bitlen = {}\r\n\tfor dist=0, 31 do\r\n\t\t_fix_block_dist_huffman_bitlen[dist] = 5\r\n\tend\r\n\tlocal status\r\n\tstatus, _fix_block_literal_huffman_bitlen_count\r\n\t\t, _fix_block_literal_huffman_to_deflate_code =\r\n\t\tGetHuffmanForDecode(_fix_block_literal_huffman_bitlen, 287, 9)\r\n\tassert(status == 0)\r\n\tstatus, _fix_block_dist_huffman_bitlen_count,\r\n\t\t_fix_block_dist_huffman_to_deflate_code =\r\n\t\tGetHuffmanForDecode(_fix_block_dist_huffman_bitlen, 31, 5)\r\n\tassert(status == 0)\r\n\r\n\t_fix_block_literal_huffman_code =\r\n\t\tGetHuffmanCodeFromBitlen(_fix_block_literal_huffman_bitlen_count\r\n\t\t, _fix_block_literal_huffman_bitlen, 287, 9)\r\n\t_fix_block_dist_huffman_code =\r\n\t\tGetHuffmanCodeFromBitlen(_fix_block_dist_huffman_bitlen_count\r\n\t\t, _fix_block_dist_huffman_bitlen, 31, 5)\r\nend\r\n\r\n-- Encoding algorithms\r\n-- Prefix encoding algorithm\r\n-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com\r\n-- From LibCompress <https://www.wowace.com/projects/libcompress>,\r\n-- which is licensed under GPLv2\r\n-- The code has been modified by the author of LibDeflate.\r\n------------------------------------------------------------------------------\r\n\r\n-- to be able to match any requested byte value, the search\r\n-- string must be preprocessed characters to escape with %:\r\n-- ( ) . % + - * ? [ ] ^ $\r\n-- "illegal" byte values:\r\n-- 0 is replaces %z\r\nlocal _gsub_escape_table = {\r\n\t["\\000"] = "%z", ["("] = "%(", [")"] = "%)", ["."] = "%.",\r\n\t["%"] = "%%", ["+"] = "%+", ["-"] = "%-", ["*"] = "%*",\r\n\t["?"] = "%?", ["["] = "%[", ["]"] = "%]", ["^"] = "%^",\r\n\t["$"] = "%$",\r\n}\r\n\r\nlocal function escape_for_gsub(str)\r\n\treturn str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])", _gsub_escape_table)\r\nend\r\n\r\n--- Create a custom codec with encoder and decoder. <br>\r\n-- This codec is used to convert an input string to make it not contain\r\n-- some specific bytes.\r\n-- This created codec and the parameters of this function do NOT take\r\n-- localization into account. One byte (0-255) in the string is exactly one\r\n-- character (0-255).\r\n-- Credits to LibCompress.\r\n-- @param reserved_chars [string] The created encoder will ensure encoded\r\n-- data does not contain any single character in reserved_chars. This parameter\r\n-- should be non-empty.\r\n-- @param escape_chars [string] The escape character(s) used in the created\r\n-- codec. The codec converts any character included in reserved\\_chars /\r\n-- escape\\_chars / map\\_chars to (one escape char + one character not in\r\n-- reserved\\_chars / escape\\_chars / map\\_chars).\r\n-- You usually only need to provide a length-1 string for this parameter.\r\n-- Length-2 string is only needed when\r\n-- reserved\\_chars + escape\\_chars + map\\_chars is longer than 127.\r\n-- This parameter should be non-empty.\r\n-- @param map_chars [string] The created encoder will map every\r\n-- reserved\\_chars:sub(i, i) (1 <= i <= #map\\_chars) to map\\_chars:sub(i, i).\r\n-- This parameter CAN be empty string.\r\n-- @return [table/nil] If the codec cannot be created, return nil.<br>\r\n-- If the codec can be created according to the given\r\n-- parameters, return the codec, which is a encode/decode table.\r\n-- The table contains two functions: <br>\r\n-- t:Encode(str) returns the encoded string. <br>\r\n-- t:Decode(str) returns the decoded string if succeeds. nil if fails.\r\n-- @return [nil/string] If the codec is successfully created, return nil.\r\n-- If not, return a string that describes the reason why the codec cannot be\r\n-- created.\r\n-- @usage\r\n-- -- Create an encoder/decoder that maps all "\\000" to "\\003",\r\n-- -- and escape "\\001" (and "\\002" and "\\003") properly\r\n-- local codec = LibDeflate:CreateCodec("\\000\\001", "\\002", "\\003")\r\n--\r\n-- local encoded = codec:Encode(SOME_STRING)\r\n-- -- "encoded" does not contain "\\000" or "\\001"\r\n-- local decoded = codec:Decode(encoded)\r\n-- -- assert(decoded == SOME_STRING)\r\nfunction LibDeflate:CreateCodec(reserved_chars, escape_chars\r\n\t, map_chars)\r\n\t-- select a default escape character\r\n\tif type(reserved_chars) ~= "string"\r\n\t\tor type(escape_chars) ~= "string"\r\n\t\tor type(map_chars) ~= "string" then\r\n\t\t\terror(\r\n\t\t\t\t"Usage: LibDeflate:CreateCodec(reserved_chars,"\r\n\t\t\t\t.." escape_chars, map_chars):"\r\n\t\t\t\t.." All arguments must be string.", 2)\r\n\tend\r\n\r\n\tif escape_chars == "" then\r\n\t\treturn nil, "No escape characters supplied."\r\n\tend\r\n\tif #reserved_chars < #map_chars then\r\n\t\treturn nil, "The number of reserved characters must be"\r\n\t\t\t.." at least as many as the number of mapped chars."\r\n\tend\r\n\tif reserved_chars == "" then\r\n\t\treturn nil, "No characters to encode."\r\n\tend\r\n\r\n\tlocal encode_bytes = reserved_chars..escape_chars..map_chars\r\n\t-- build list of bytes not available as a suffix to a prefix byte\r\n\tlocal taken = {}\r\n\tfor i = 1, #encode_bytes do\r\n\t\tlocal byte = string_byte(encode_bytes, i, i)\r\n\t\tif taken[byte] then -- Modified by LibDeflate:\r\n\t\t\treturn nil, "There must be no duplicate characters in the"\r\n\t\t\t\t.." concatenation of reserved_chars, escape_chars and"\r\n\t\t\t\t.." map_chars."\r\n\t\tend\r\n\t\ttaken[byte] = true\r\n\tend\r\n\r\n\t-- Modified by LibDeflate:\r\n\t-- Store the patterns and replacement in tables for later use.\r\n\t-- This function is modified that loadstring() lua api is no longer used.\r\n\tlocal decode_patterns = {}\r\n\tlocal decode_repls = {}\r\n\r\n\t-- the encoding can be a single gsub\r\n\t-- , but the decoding can require multiple gsubs\r\n\tlocal encode_search = {}\r\n\tlocal encode_translate = {}\r\n\r\n\t-- map single byte to single byte\r\n\tif #map_chars > 0 then\r\n\t\tlocal decode_search = {}\r\n\t\tlocal decode_translate = {}\r\n\t\tfor i = 1, #map_chars do\r\n\t\t\tlocal from = string_sub(reserved_chars, i, i)\r\n\t\t\tlocal to = string_sub(map_chars, i, i)\r\n\t\t\tencode_translate[from] = to\r\n\t\t\tencode_search[#encode_search+1] = from\r\n\t\t\tdecode_translate[to] = from\r\n\t\t\tdecode_search[#decode_search+1] = to\r\n\t\tend\r\n\t\tdecode_patterns[#decode_patterns+1] =\r\n\t\t\t"([".. escape_for_gsub(table_concat(decode_search)).."])"\r\n\t\tdecode_repls[#decode_repls+1] = decode_translate\r\n\tend\r\n\r\n\tlocal escape_char_index = 1\r\n\tlocal escape_char = string_sub(escape_chars\r\n\t\t, escape_char_index, escape_char_index)\r\n\t-- map single byte to double-byte\r\n\tlocal r = 0 -- suffix char value to the escapeChar\r\n\r\n\tlocal decode_search = {}\r\n\tlocal decode_translate = {}\r\n\tfor i = 1, #encode_bytes do\r\n\t\tlocal c = string_sub(encode_bytes, i, i)\r\n\t\tif not encode_translate[c] then\r\n\t\t\t-- this loop will update escapeChar and r\r\n\t\t\twhile r >= 256 or taken[r] do\r\n\t\t\t-- Bug in LibCompress r81\r\n\t\t\t-- while r < 256 and taken[r] do\r\n\t\t\t\tr = r + 1\r\n\t\t\t\tif r > 255 then -- switch to next escapeChar\r\n\t\t\t\t\tdecode_patterns[#decode_patterns+1] =\r\n\t\t\t\t\t\tescape_for_gsub(escape_char)\r\n\t\t\t\t\t\t.."(["\r\n\t\t\t\t\t\t.. escape_for_gsub(table_concat(decode_search)).."])"\r\n\t\t\t\t\tdecode_repls[#decode_repls+1] = decode_translate\r\n\r\n\t\t\t\t\tescape_char_index = escape_char_index + 1\r\n\t\t\t\t\tescape_char = string_sub(escape_chars, escape_char_index\r\n\t\t\t\t\t\t, escape_char_index)\r\n\t\t\t\t\tr = 0\r\n\t\t\t\t\tdecode_search = {}\r\n\t\t\t\t\tdecode_translate = {}\r\n\r\n\t\t\t\t\t-- Fixes Another bug in LibCompress r82.\r\n\t\t\t\t\t-- LibCompress checks this error condition\r\n\t\t\t\t\t-- right after "if r > 255 then"\r\n\t\t\t\t\t-- This is why error case should also be tested.\r\n\t\t\t\t\tif not escape_char or escape_char == "" then\r\n\t\t\t\t\t\t-- actually I don\'t need to check\r\n\t\t\t\t\t\t-- "not ecape_char", but what if Lua changes\r\n\t\t\t\t\t\t-- the behavior of string.sub() in the future?\r\n\t\t\t\t\t\t-- we are out of escape chars and we need more!\r\n\t\t\t\t\t\treturn nil, "Out of escape characters."\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tlocal char_r = _byte_to_char[r]\r\n\t\t\tencode_translate[c] = escape_char..char_r\r\n\t\t\tencode_search[#encode_search+1] = c\r\n\t\t\tdecode_translate[char_r] = c\r\n\t\t\tdecode_search[#decode_search+1] = char_r\r\n\t\t\tr = r + 1\r\n\t\tend\r\n\t\tif i == #encode_bytes then\r\n\t\t\tdecode_patterns[#decode_patterns+1] =\r\n\t\t\t\tescape_for_gsub(escape_char).."(["\r\n\t\t\t\t.. escape_for_gsub(table_concat(decode_search)).."])"\r\n\t\t\tdecode_repls[#decode_repls+1] = decode_translate\r\n\t\tend\r\n\tend\r\n\r\n\tlocal codec = {}\r\n\r\n\tlocal encode_pattern = "(["\r\n\t\t.. escape_for_gsub(table_concat(encode_search)).."])"\r\n\tlocal encode_repl = encode_translate\r\n\r\n\tfunction codec:Encode(str)\r\n\t\tif type(str) ~= "string" then\r\n\t\t\terror(("Usage: codec:Encode(str):"\r\n\t\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\t\tend\r\n\t\treturn string_gsub(str, encode_pattern, encode_repl)\r\n\tend\r\n\r\n\tlocal decode_tblsize = #decode_patterns\r\n\tlocal decode_fail_pattern = "(["\r\n\t\t.. escape_for_gsub(reserved_chars).."])"\r\n\r\n\tfunction codec:Decode(str)\r\n\t\tif type(str) ~= "string" then\r\n\t\t\terror(("Usage: codec:Decode(str):"\r\n\t\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\t\tend\r\n\t\tif string_find(str, decode_fail_pattern) then\r\n\t\t\treturn nil\r\n\t\tend\r\n\t\tfor i = 1, decode_tblsize do\r\n\t\t\tstr = string_gsub(str, decode_patterns[i], decode_repls[i])\r\n\t\tend\r\n\t\treturn str\r\n\tend\r\n\r\n\treturn codec\r\nend\r\n\r\nlocal _addon_channel_codec\r\n\r\nlocal function GenerateWoWAddonChannelCodec()\r\n\treturn LibDeflate:CreateCodec("\\000", "\\001", "")\r\nend\r\n\r\n--- Encode the string to make it ready to be transmitted in World of\r\n-- Warcraft addon channel. <br>\r\n-- The encoded string is guaranteed to contain no NULL ("\\000") character.\r\n-- @param str [string] The string to be encoded.\r\n-- @return The encoded string.\r\n-- @see LibDeflate:DecodeForWoWAddonChannel\r\nfunction LibDeflate:EncodeForWoWAddonChannel(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:EncodeForWoWAddonChannel(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tif not _addon_channel_codec then\r\n\t\t_addon_channel_codec = GenerateWoWAddonChannelCodec()\r\n\tend\r\n\treturn _addon_channel_codec:Encode(str)\r\nend\r\n\r\n--- Decode the string produced by LibDeflate:EncodeForWoWAddonChannel\r\n-- @param str [string] The string to be decoded.\r\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\r\n-- @see LibDeflate:EncodeForWoWAddonChannel\r\nfunction LibDeflate:DecodeForWoWAddonChannel(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:DecodeForWoWAddonChannel(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tif not _addon_channel_codec then\r\n\t\t_addon_channel_codec = GenerateWoWAddonChannelCodec()\r\n\tend\r\n\treturn _addon_channel_codec:Decode(str)\r\nend\r\n\r\n-- For World of Warcraft Chat Channel Encoding\r\n-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com\r\n-- From LibCompress <https://www.wowace.com/projects/libcompress>,\r\n-- which is licensed under GPLv2\r\n-- The code has been modified by the author of LibDeflate.\r\n-- Following byte values are not allowed:\r\n-- \\000, s, S, \\010, \\013, \\124, %\r\n-- Because SendChatMessage will error\r\n-- if an UTF8 multibyte character is incomplete,\r\n-- all character values above 127 have to be encoded to avoid this.\r\n-- This costs quite a bit of bandwidth (about 13-14%)\r\n-- Also, because drunken status is unknown for the received\r\n-- , strings used with SendChatMessage should be terminated with\r\n-- an identifying byte value, after which the server MAY add "...hic!"\r\n-- or as much as it can fit(!).\r\n-- Pass the identifying byte as a reserved character to this function\r\n-- to ensure the encoding doesn\'t contain that value.\r\n-- or use this: local message, match = arg1:gsub("^(.*)\\029.-$", "%1")\r\n-- arg1 is message from channel, \\029 is the string terminator\r\n-- , but may be used in the encoded datastream as well. :-)\r\n-- This encoding will expand data anywhere from:\r\n-- 0% (average with pure ascii text)\r\n-- 53.5% (average with random data valued zero to 255)\r\n-- 100% (only encoding data that encodes to two bytes)\r\nlocal function GenerateWoWChatChannelCodec()\r\n\tlocal r = {}\r\n\tfor i = 128, 255 do\r\n\t\tr[#r+1] = _byte_to_char[i]\r\n\tend\r\n\r\n\tlocal reserved_chars = "sS\\000\\010\\013\\124%"..table_concat(r)\r\n\treturn LibDeflate:CreateCodec(reserved_chars\r\n\t\t, "\\029\\031", "\\015\\020")\r\nend\r\n\r\nlocal _chat_channel_codec\r\n\r\n--- Encode the string to make it ready to be transmitted in World of\r\n-- Warcraft chat channel. <br>\r\n-- See also https://wow.gamepedia.com/ValidChatMessageCharacters\r\n-- @param str [string] The string to be encoded.\r\n-- @return [string] The encoded string.\r\n-- @see LibDeflate:DecodeForWoWChatChannel\r\nfunction LibDeflate:EncodeForWoWChatChannel(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:EncodeForWoWChatChannel(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tif not _chat_channel_codec then\r\n\t\t_chat_channel_codec = GenerateWoWChatChannelCodec()\r\n\tend\r\n\treturn _chat_channel_codec:Encode(str)\r\nend\r\n\r\n--- Decode the string produced by LibDeflate:EncodeForWoWChatChannel.\r\n-- @param str [string] The string to be decoded.\r\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\r\n-- @see LibDeflate:EncodeForWoWChatChannel\r\nfunction LibDeflate:DecodeForWoWChatChannel(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:DecodeForWoWChatChannel(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tif not _chat_channel_codec then\r\n\t\t_chat_channel_codec = GenerateWoWChatChannelCodec()\r\n\tend\r\n\treturn _chat_channel_codec:Decode(str)\r\nend\r\n\r\n-- Credits to WeakAuras <https://github.com/WeakAuras/WeakAuras2>,\r\n-- and Galmok (galmok@gmail.com) for the 6 bit encoding algorithm.\r\n-- The result of encoding will be 25% larger than the\r\n-- origin string, but every single byte of the encoding result will be\r\n-- printable characters as the following.\r\nlocal _byte_to_6bit_char = {\r\n\t[0]="a", "b", "c", "d", "e", "f", "g", "h",\r\n\t"i", "j", "k", "l", "m", "n", "o", "p",\r\n\t"q", "r", "s", "t", "u", "v", "w", "x",\r\n\t"y", "z", "A", "B", "C", "D", "E", "F",\r\n\t"G", "H", "I", "J", "K", "L", "M", "N",\r\n\t"O", "P", "Q", "R", "S", "T", "U", "V",\r\n\t"W", "X", "Y", "Z", "0", "1", "2", "3",\r\n\t"4", "5", "6", "7", "8", "9", "(", ")",\r\n}\r\n\r\nlocal _6bit_to_byte = {\r\n\t[97]=0,[98]=1,[99]=2,[100]=3,[101]=4,[102]=5,[103]=6,[104]=7,\r\n\t[105]=8,[106]=9,[107]=10,[108]=11,[109]=12,[110]=13,[111]=14,[112]=15,\r\n\t[113]=16,[114]=17,[115]=18,[116]=19,[117]=20,[118]=21,[119]=22,[120]=23,\r\n\t[121]=24,[122]=25,[65]=26,[66]=27,[67]=28,[68]=29,[69]=30,[70]=31,\r\n\t[71]=32,[72]=33,[73]=34,[74]=35,[75]=36,[76]=37,[77]=38,[78]=39,\r\n\t[79]=40,[80]=41,[81]=42,[82]=43,[83]=44,[84]=45,[85]=46,[86]=47,\r\n\t[87]=48,[88]=49,[89]=50,[90]=51,[48]=52,[49]=53,[50]=54,[51]=55,\r\n\t[52]=56,[53]=57,[54]=58,[55]=59,[56]=60,[57]=61,[40]=62,[41]=63,\r\n}\r\n\r\nfunction clgDecompress(str) return LibDeflate:DecompressDeflate(LibDeflate:DecodeForPrint(str))end function clgCompress(str) return LibDeflate:EncodeForPrint(LibDeflate:CompressDeflate(str))end\r\n--- Encode the string to make it printable. <br>\r\n--\r\n-- Credis to WeakAuras2, this function is equivalant to the implementation\r\n-- it is using right now. <br>\r\n-- The encoded string will be 25% larger than the origin string. However, every\r\n-- single byte of the encoded string will be one of 64 printable ASCII\r\n-- characters, which are can be easier copied, pasted and displayed.\r\n-- (26 lowercase letters, 26 uppercase letters, 10 numbers digits,\r\n-- left parenthese, or right parenthese)\r\n-- @param str [string] The string to be encoded.\r\n-- @return [string] The encoded string.\r\nfunction LibDeflate:EncodeForPrint(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:EncodeForPrint(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tlocal strlen = #str\r\n\tlocal strlenMinus2 = strlen - 2\r\n\tlocal i = 1\r\n\tlocal buffer = {}\r\n\tlocal buffer_size = 0\r\n\twhile i <= strlenMinus2 do\r\n\t\tlocal x1, x2, x3 = string_byte(str, i, i+2)\r\n\t\ti = i + 3\r\n\t\tlocal cache = x1+x2*256+x3*65536\r\n\t\tlocal b1 = cache % 64\r\n\t\tcache = (cache - b1) / 64\r\n\t\tlocal b2 = cache % 64\r\n\t\tcache = (cache - b2) / 64\r\n\t\tlocal b3 = cache % 64\r\n\t\tlocal b4 = (cache - b3) / 64\r\n\t\tbuffer_size = buffer_size + 1\r\n\t\tbuffer[buffer_size] =\r\n\t\t\t_byte_to_6bit_char[b1].._byte_to_6bit_char[b2]\r\n\t\t\t.._byte_to_6bit_char[b3].._byte_to_6bit_char[b4]\r\n\tend\r\n\r\n\tlocal cache = 0\r\n\tlocal cache_bitlen = 0\r\n\twhile i <= strlen do\r\n\t\tlocal x = string_byte(str, i, i)\r\n\t\tcache = cache + x * _pow2[cache_bitlen]\r\n\t\tcache_bitlen = cache_bitlen + 8\r\n\t\ti = i + 1\r\n\tend\r\n\twhile cache_bitlen > 0 do\r\n\t\tlocal bit6 = cache % 64\r\n\t\tbuffer_size = buffer_size + 1\r\n\t\tbuffer[buffer_size] = _byte_to_6bit_char[bit6]\r\n\t\tcache = (cache - bit6) / 64\r\n\t\tcache_bitlen = cache_bitlen - 6\r\n\tend\r\n\r\n\treturn table_concat(buffer)\r\nend\r\n\r\n--- Decode the printable string produced by LibDeflate:EncodeForPrint.\r\n-- "str" will have its prefixed and trailing control characters or space\r\n-- removed before it is decoded, so it is easier to use if "str" comes form\r\n-- user copy and paste with some prefixed or trailing spaces.\r\n-- Then decode fails if the string contains any characters cant be produced by\r\n-- LibDeflate:EncodeForPrint. That means, decode fails if the string contains a\r\n-- characters NOT one of 26 lowercase letters, 26 uppercase letters,\r\n-- 10 numbers digits, left parenthese, or right parenthese.\r\n-- @param str [string] The string to be decoded\r\n-- @return [string/nil] The decoded string if succeeds. nil if fails.\r\nfunction LibDeflate:DecodeForPrint(str)\r\n\tif type(str) ~= "string" then\r\n\t\terror(("Usage: LibDeflate:DecodeForPrint(str):"\r\n\t\t\t.." \'str\' - string expected got \'%s\'."):format(type(str)), 2)\r\n\tend\r\n\tstr = str:gsub("^[%c ]+", "")\r\n\tstr = str:gsub("[%c ]+$", "")\r\n\r\n\tlocal strlen = #str\r\n\tif strlen == 1 then\r\n\t\treturn nil\r\n\tend\r\n\tlocal strlenMinus3 = strlen - 3\r\n\tlocal i = 1\r\n\tlocal buffer = {}\r\n\tlocal buffer_size = 0\r\n\twhile i <= strlenMinus3 do\r\n\t\tlocal x1, x2, x3, x4 = string_byte(str, i, i+3)\r\n\t\tx1 = _6bit_to_byte[x1]\r\n\t\tx2 = _6bit_to_byte[x2]\r\n\t\tx3 = _6bit_to_byte[x3]\r\n\t\tx4 = _6bit_to_byte[x4]\r\n\t\tif not (x1 and x2 and x3 and x4) then\r\n\t\t\treturn nil\r\n\t\tend\r\n\t\ti = i + 4\r\n\t\tlocal cache = x1+x2*64+x3*4096+x4*262144\r\n\t\tlocal b1 = cache % 256\r\n\t\tcache = (cache - b1) / 256\r\n\t\tlocal b2 = cache % 256\r\n\t\tlocal b3 = (cache - b2) / 256\r\n\t\tbuffer_size = buffer_size + 1\r\n\t\tbuffer[buffer_size] =\r\n\t\t\t_byte_to_char[b1].._byte_to_char[b2].._byte_to_char[b3]\r\n\tend\r\n\r\n\tlocal cache  = 0\r\n\tlocal cache_bitlen = 0\r\n\twhile i <= strlen do\r\n\t\tlocal x = string_byte(str, i, i)\r\n\t\tx =  _6bit_to_byte[x]\r\n\t\tif not x then\r\n\t\t\treturn nil\r\n\t\tend\r\n\t\tcache = cache + x * _pow2[cache_bitlen]\r\n\t\tcache_bitlen = cache_bitlen + 6\r\n\t\ti = i + 1\r\n\tend\r\n\r\n\twhile cache_bitlen >= 8 do\r\n\t\tlocal byte = cache % 256\r\n\t\tbuffer_size = buffer_size + 1\r\n\t\tbuffer[buffer_size] = _byte_to_char[byte]\r\n\t\tcache = (cache - byte) / 256\r\n\t\tcache_bitlen = cache_bitlen - 8\r\n\tend\r\n\r\n\treturn table_concat(buffer)\r\nend\r\n\r\nlocal function InternalClearCache()\r\n\t_chat_channel_codec = nil\r\n\t_addon_channel_codec = nil\r\nend\r\n\r\n-- For test. Don\'t use the functions in this table for real application.\r\n-- Stuffs in this table is subject to change.\r\nLibDeflate.internals = {\r\n\tLoadStringToTable = LoadStringToTable,\r\n\tIsValidDictionary = IsValidDictionary,\r\n\tIsEqualAdler32 = IsEqualAdler32,\r\n\t_byte_to_6bit_char = _byte_to_6bit_char,\r\n\t_6bit_to_byte = _6bit_to_byte,\r\n\tInternalClearCache = InternalClearCache,\r\n}\r\n\r\n--[[-- Commandline options\r\n@class table\r\n@name CommandlineOptions\r\n@usage lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\r\n\\-0    store only. no compression.\r\n\\-1    fastest compression.\r\n\\-9    slowest and best compression.\r\n\\-d    do decompression instead of compression.\r\n\\--dict <filename> specify the file that contains\r\nthe entire preset dictionary.\r\n\\-h    give this help.\r\n\\--strategy <fixed/huffman_only/dynamic> specify a special compression strategy.\r\n\\-v    print the version and copyright info.\r\n\\--zlib  use zlib format instead of raw deflate.\r\n]]\r\n\r\n-- currently no plan to support stdin and stdout.\r\n-- Because Lua in Windows does not set stdout with binary mode.\r\nif io and os and debug and _G.arg then\r\n\tlocal io = io\r\n\tlocal os = os\r\n\tlocal debug = debug\r\n\tlocal arg = _G.arg\r\n\tlocal debug_info = debug.getinfo(1)\r\n\tif debug_info.source == arg[0]\r\n\t\tor debug_info.short_src == arg[0] then\r\n\t-- We are indeed runnning THIS file from the commandline.\r\n\t\tlocal input\r\n\t\tlocal output\r\n\t\tlocal i = 1\r\n\t\tlocal status\r\n\t\tlocal is_zlib = false\r\n\t\tlocal is_decompress = false\r\n\t\tlocal level\r\n\t\tlocal strategy\r\n\t\tlocal dictionary\r\n\t\twhile (arg[i]) do\r\n\t\t\tlocal a = arg[i]\r\n\t\t\tif a == "-h" then\r\n\t\t\t\tprint(LibDeflate._COPYRIGHT\r\n\t\t\t\t\t.."\\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\\n"\r\n\t\t\t\t\t.."  -0    store only. no compression.\\n"\r\n\t\t\t\t\t.."  -1    fastest compression.\\n"\r\n\t\t\t\t\t.."  -9    slowest and best compression.\\n"\r\n\t\t\t\t\t.."  -d    do decompression instead of compression.\\n"\r\n\t\t\t\t\t.."  --dict <filename> specify the file that contains"\r\n\t\t\t\t\t.." the entire preset dictionary.\\n"\r\n\t\t\t\t\t.."  -h    give this help.\\n"\r\n\t\t\t\t\t.."  --strategy <fixed/huffman_only/dynamic>"\r\n\t\t\t\t\t.." specify a special compression strategy.\\n"\r\n\t\t\t\t\t.."  -v    print the version and copyright info.\\n"\r\n\t\t\t\t\t.."  --zlib  use zlib format instead of raw deflate.\\n")\r\n\t\t\t\tos.exit(0)\r\n\t\t\telseif a == "-v" then\r\n\t\t\t\tprint(LibDeflate._COPYRIGHT)\r\n\t\t\t\tos.exit(0)\r\n\t\t\telseif a:find("^%-[0-9]$") then\r\n\t\t\t\tlevel = tonumber(a:sub(2, 2))\r\n\t\t\telseif a == "-d" then\r\n\t\t\t\tis_decompress = true\r\n\t\t\telseif a == "--dict" then\r\n\t\t\t\ti = i + 1\r\n\t\t\t\tlocal dict_filename = arg[i]\r\n\t\t\t\tif not dict_filename then\r\n\t\t\t\t\tio.stderr:write("You must speicify the dict filename")\r\n\t\t\t\t\tos.exit(1)\r\n\t\t\t\tend\r\n\t\t\t\tlocal dict_file, dict_status = io.open(dict_filename, "rb")\r\n\t\t\t\tif not dict_file then\r\n\t\t\t\t\tio.stderr:write(\r\n\t\t\t\t\t("LibDeflate: Cannot read the dictionary file \'%s\': %s")\r\n\t\t\t\t\t:format(dict_filename, dict_status))\r\n\t\t\t\t\tos.exit(1)\r\n\t\t\t\tend\r\n\t\t\t\tlocal dict_str = dict_file:read("*all")\r\n\t\t\t\tdict_file:close()\r\n\t\t\t\t-- In your lua program, you should pass in adler32 as a CONSTANT\r\n\t\t\t\t-- , so it actually prevent you from modifying dictionary\r\n\t\t\t\t-- unintentionally during the program development. I do this\r\n\t\t\t\t-- here just because no convenient way to verify in commandline.\r\n\t\t\t\tdictionary = LibDeflate:CreateDictionary(dict_str,\r\n\t\t\t\t\t#dict_str, LibDeflate:Adler32(dict_str))\r\n\t\t\telseif a == "--strategy" then\r\n\t\t\t\t-- Not sure if I should check error here\r\n\t\t\t\t-- If I do, redudant code.\r\n\t\t\t\ti = i + 1\r\n\t\t\t\tstrategy = arg[i]\r\n\t\t\telseif a == "--zlib" then\r\n\t\t\t\tis_zlib = true\r\n\t\t\telseif a:find("^%-") then\r\n\t\t\t\tio.stderr:write(("LibDeflate: Invalid argument: %s")\r\n\t\t\t\t\t\t:format(a))\r\n\t\t\t\tos.exit(1)\r\n\t\t\telse\r\n\t\t\t\tif not input then\r\n\t\t\t\t\tinput, status = io.open(a, "rb")\r\n\t\t\t\t\tif not input then\r\n\t\t\t\t\t\tio.stderr:write(\r\n\t\t\t\t\t\t\t("LibDeflate: Cannot read the file \'%s\': %s")\r\n\t\t\t\t\t\t\t:format(a, tostring(status)))\r\n\t\t\t\t\t\tos.exit(1)\r\n\t\t\t\t\tend\r\n\t\t\t\telseif not output then\r\n\t\t\t\t\toutput, status = io.open(a, "wb")\r\n\t\t\t\t\tif not output then\r\n\t\t\t\t\t\tio.stderr:write(\r\n\t\t\t\t\t\t\t("LibDeflate: Cannot write the file \'%s\': %s")\r\n\t\t\t\t\t\t\t:format(a, tostring(status)))\r\n\t\t\t\t\t\tos.exit(1)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\ti = i + 1\r\n\t\tend -- while (arg[i])\r\n\r\n\t\tif not input or not output then\r\n\t\t\tio.stderr:write("LibDeflate:"\r\n\t\t\t\t.." You must specify both input and output files.")\r\n\t\t\tos.exit(1)\r\n\t\tend\r\n\r\n\t\tlocal input_data = input:read("*all")\r\n\t\tlocal configs = {\r\n\t\t\tlevel = level,\r\n\t\t\tstrategy = strategy,\r\n\t\t}\r\n\t\tlocal output_data\r\n\t\tif not is_decompress then\r\n\t\t\tif not is_zlib then\r\n\t\t\t\tif not dictionary then\r\n\t\t\t\t\toutput_data =\r\n\t\t\t\t\tLibDeflate:CompressDeflate(input_data, configs)\r\n\t\t\t\telse\r\n\t\t\t\t\toutput_data =\r\n\t\t\t\t\tLibDeflate:CompressDeflateWithDict(input_data, dictionary\r\n\t\t\t\t\t\t, configs)\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tif not dictionary then\r\n\t\t\t\t\toutput_data =\r\n\t\t\t\t\tLibDeflate:CompressZlib(input_data, configs)\r\n\t\t\t\telse\r\n\t\t\t\t\toutput_data =\r\n\t\t\t\t\tLibDeflate:CompressZlibWithDict(input_data, dictionary\r\n\t\t\t\t\t\t, configs)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tif not is_zlib then\r\n\t\t\t\tif not dictionary then\r\n\t\t\t\t\toutput_data = LibDeflate:DecompressDeflate(input_data)\r\n\t\t\t\telse\r\n\t\t\t\t\toutput_data = LibDeflate:DecompressDeflateWithDict(\r\n\t\t\t\t\t\tinput_data, dictionary)\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tif not dictionary then\r\n\t\t\t\t\toutput_data = LibDeflate:DecompressZlib(input_data)\r\n\t\t\t\telse\r\n\t\t\t\t\toutput_data = LibDeflate:DecompressZlibWithDict(\r\n\t\t\t\t\t\tinput_data, dictionary)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tif not output_data then\r\n\t\t\tio.stderr:write("LibDeflate: Decompress fails.")\r\n\t\t\tos.exit(1)\r\n\t\tend\r\n\r\n\t\toutput:write(output_data)\r\n\t\tif input and input ~= io.stdin then\r\n\t\t\tinput:close()\r\n\t\tend\r\n\t\tif output and output ~= io.stdout then\r\n\t\t\toutput:close()\r\n\t\tend\r\n\r\n\t\tio.stderr:write(("Successfully writes %d bytes"):format(\r\n\t\t\toutput_data:len()))\r\n\t\tos.exit(0)\r\n\tend\r\nend\r\n return LibDeflate\r\n', "@./LibDeflate.lua").call("./LibDeflate.lua")
//console.log(fengari)
  //var lol = "lAdI12ORwj)8xjDuYJuZjN8vQwDQwdLc0tFushd1S2yb8d";
  //var compressed = fengari.load(`return clgDecompress('`+lol+`')`)();
  //console.log(compressed);
  
//var result = fengari.load('return LibDeflate:DecompressDeflate("'+compressed+'")')()
//console.log(result);
Decoder::decodeAura("lAdI12ORwj)8xjDuYJuZjN8vQwDQwdLc0tFushd1S2yb8d")
</script>
</body>
</html>